  $ narya -v constants.ny
   ï¿« info[I0000]
   ï¿® constant CN defined
  
   ï¿« info[I0000]
   ï¿® constant zero defined
  
   ï¿« info[I0000]
   ï¿® constant one defined
  
   ï¿« info[I0000]
   ï¿® constant two defined
  
   ï¿« info[I0000]
   ï¿® constant three defined
  
   ï¿« info[I0000]
   ï¿® constant four defined
  
   ï¿« info[I0000]
   ï¿® constant one_eq defined
  
   ï¿« info[I0000]
   ï¿® constant cplus defined
  
   ï¿« info[I0000]
   ï¿® constant cplus_one_one_eq_two defined
  
   ï¿« info[I0000]
   ï¿® constant ctimes defined
  
   ï¿« info[I0000]
   ï¿® constant ctimes_two_two_eq_four defined
  
   ï¿« info[I0000]
   ï¿® constant Î£ defined
  
   ï¿« info[I0000]
   ï¿® constant zero_zero defined
  
   ï¿« info[I0000]
   ï¿® constant zero_zero_fst_eq_zero defined
  
   ï¿« info[I0000]
   ï¿® constant zero_zero_snd_eq_zero defined
  
   ï¿« info[I0001]
   ï¿® axiom A assumed
  
   ï¿« info[I0001]
   ï¿® axiom B assumed
  
   ï¿« info[I0001]
   ï¿® axiom a assumed
  
   ï¿« info[I0001]
   ï¿® axiom b assumed
  
   ï¿« info[I0000]
   ï¿® constant ab defined
  
   ï¿« info[I0000]
   ï¿® constant ab_fst_eq_a defined
  
   ï¿« info[I0000]
   ï¿® constant ab_snd_eq_b defined
  
   ï¿« info[I0000]
   ï¿® constant ab_fst_eq_a' defined
  
   ï¿« info[I0000]
   ï¿® constant ab_snd_eq_b' defined
  
   ï¿« info[I0000]
   ï¿® constant zero_zero' defined
  
   ï¿« info[I0000]
   ï¿® constant zero_zero_eq_zero_zero' defined
  
   ï¿« info[I0000]
   ï¿® constant Stream defined
  
   ï¿« info[I0000]
   ï¿® constant zeros defined
  
   ï¿« info[I0000]
   ï¿® constant zeros_first_term_eq_zero defined
  
   ï¿« info[I0000]
   ï¿® constant zeros_second_term_eq_zero defined
  
   ï¿« info[I0000]
   ï¿® constant zeros_third_term_eq_zero defined
  
   ï¿« info[I0000]
   ï¿® constant zeros_fourth_term_eq_zero defined
  
   ï¿« info[I0000]
   ï¿® constant nats defined
  
   ï¿« info[I0000]
   ï¿® constant nats_zero_third_term_eq_two defined
  
   ï¿« info[I0000]
   ï¿® constant nats_zero_fifth_term_eq_four defined
  
   ï¿« info[I0000]
   ï¿® constant âˆeta defined
  
   ï¿« info[I0000]
   ï¿® constant âˆeta_bisim defined
  
   ï¿« info[I0000]
   ï¿® constant â„• defined
  
   ï¿« info[I0000]
   ï¿® constant Nat defined
  
   ï¿« info[I0000]
   ï¿® constant plus defined
  
   ï¿« info[I0000]
   ï¿® constant times defined
  
   ï¿« info[I0000]
   ï¿® constant List defined
  
   ï¿« info[I0000]
   ï¿® constant append defined
  
   ï¿« info[I0000]
   ï¿® constant append_eq_sample defined
  
   ï¿« info[I0000]
   ï¿® constant Vec defined
  
   ï¿« info[I0000]
   ï¿® constant lplus defined
  
   ï¿« info[I0000]
   ï¿® constant vappend defined
  
   ï¿« info[I0000]
   ï¿® constant vappend_eq_sample defined
  
   ï¿« info[I0000]
   ï¿® constant exp defined
  
   ï¿« info[I0000]
   ï¿® constant exp_eq_sample defined
  
   ï¿« info[I0000]
   ï¿® constant exp2 defined
  
   ï¿« info[I0000]
   ï¿® constant exp_eq_sample' defined
  
   ï¿« info[I0000]
   ï¿® constant âˆ… defined
  
   ï¿« info[I0000]
   ï¿® constant abort1 defined
  
   ï¿« info[I0000]
   ï¿® constant abort2 defined
  
   ï¿« info[I0001]
   ï¿® axiom f assumed
  
   ï¿« info[I0000]
   ï¿® constant reflf defined
  
   ï¿« info[I0000]
   ï¿® constant reflf_eq_reflf defined
  
   ï¿« info[I0000]
   ï¿® constant refl_abort_f defined
  
   ï¿« info[I0000]
   ï¿® constant refl_nat_f defined
  
   ï¿« info[I0000]
   ï¿® constant refl_nat_f_eq_reflf defined
  
   ï¿« info[I0000]
   ï¿® constant refl_abort_f_cube defined
  
   ï¿« info[I0000]
   ï¿® constant refl_nat_f_cube defined
  
   ï¿« info[I0000]
   ï¿® constant evaluated_eq_sample defined
  
   ï¿« info[I0000]
   ï¿® constant foo defined
  
   ï¿« info[I0000]
   ï¿® constant bar defined
  
   ï¿« info[I0000]
   ï¿® constant bar_eq_sample defined
  
   ï¿« info[I0000]
   ï¿® constant bar_eq_sample' defined
  
   ï¿« info[I0000]
   ï¿® constant prec defined
  
   ï¿« info[I0000]
   ï¿® constant idnat defined
  
   ï¿« info[I0000]
   ï¿® constant apprec defined
  
   ï¿« info[I0000]
   ï¿® constant âŠ¤ defined
  
   ï¿« info[I0000]
   ï¿® constant code defined
  
   ï¿« info[I0000]
   ï¿® constant rcode defined
  
   ï¿« info[I0000]
   ï¿® constant encode defined
  
   ï¿« info[I0000]
   ï¿® constant decode defined
  
   ï¿« info[I0000]
   ï¿® constant encode_decode defined
  
   ï¿« info[I0000]
   ï¿® constant decode_encode defined
  
   ï¿« info[I0000]
   ï¿® constant mtchbd0 defined
  
   ï¿« info[I0000]
   ï¿® constant mtchbd0' defined
  
   ï¿« info[I0000]
   ï¿® constant mtchbd0'' defined
  
   ï¿« info[I0000]
   ï¿® constant mtchtup defined
  
   ï¿« info[I0000]
   ï¿® constant mtchtup2 defined
  
   ï¿« info[I0000]
   ï¿® constant Covec defined
  
   ï¿« info[I0000]
   ï¿® constant nil defined
  
   ï¿« info[I0000]
   ï¿® constant onetwo defined
  
   ï¿« info[I0000]
   ï¿® constant covec_eq_sample defined
  
   ï¿« info[I0000]
   ï¿® constant covec_eq_sample' defined
  
   ï¿« info[I0000]
   ï¿® constant covec_eq_sample'' defined
  
   ï¿« info[I0000]
   ï¿® constant coconcat defined
  
  $ narya constants.ny -e "def one_eq_zero : Id CN one zero := refl one" 
   ï¿« error[E0401]
   ï¿­ command-line exec string
   1 | def one_eq_zero : Id CN one zero := refl one
     ^ term synthesized type
         {Aâ‚€ : Type} {Aâ‚ : Type} (Aâ‚‚ : Typeâ½áµ‰â¾ Aâ‚€ Aâ‚) {ğ‘¥â‚€ : Aâ‚€ â†’ Aâ‚€} {ğ‘¥â‚ : Aâ‚ â†’ Aâ‚}
         (ğ‘¥â‚‚ : {ğ‘¦â‚€ : Aâ‚€} {ğ‘¦â‚ : Aâ‚} (ğ‘¦â‚‚ : Aâ‚‚ ğ‘¦â‚€ ğ‘¦â‚) â†’â½áµ‰â¾ Aâ‚‚ (ğ‘¥â‚€ ğ‘¦â‚€) (ğ‘¥â‚ ğ‘¦â‚)) {ğ‘¦â‚€ : Aâ‚€}
         {ğ‘¦â‚ : Aâ‚} (ğ‘¦â‚‚ : Aâ‚‚ ğ‘¦â‚€ ğ‘¦â‚)
         â†’â½áµ‰â¾ Aâ‚‚ (ğ‘¥â‚€ ğ‘¦â‚€) (ğ‘¥â‚ ğ‘¦â‚)
       but is being checked against type
         {Aâ‚€ : Type} {Aâ‚ : Type} (Aâ‚‚ : Typeâ½áµ‰â¾ Aâ‚€ Aâ‚) {ğ‘¥â‚€ : Aâ‚€ â†’ Aâ‚€} {ğ‘¥â‚ : Aâ‚ â†’ Aâ‚}
         (ğ‘¥â‚‚ : {ğ‘¦â‚€ : Aâ‚€} {ğ‘¦â‚ : Aâ‚} (ğ‘¦â‚‚ : Aâ‚‚ ğ‘¦â‚€ ğ‘¦â‚) â†’â½áµ‰â¾ Aâ‚‚ (ğ‘¥â‚€ ğ‘¦â‚€) (ğ‘¥â‚ ğ‘¦â‚)) {ğ‘¦â‚€ : Aâ‚€}
         {ğ‘¦â‚ : Aâ‚} (ğ‘¦â‚‚ : Aâ‚‚ ğ‘¦â‚€ ğ‘¦â‚)
         â†’â½áµ‰â¾ Aâ‚‚ (ğ‘¥â‚€ ğ‘¦â‚€) ğ‘¦â‚
       unequal head variables:
         _H
       does not equal
         _H
  
  [1]
  $ narya constants.ny -e "def cplus_one_two_eq_two : Id CN (cplus one two) two := refl two"
   ï¿« error[E0401]
   ï¿­ command-line exec string
   1 | def cplus_one_two_eq_two : Id CN (cplus one two) two := refl two
     ^ term synthesized type
         {Aâ‚€ : Type} {Aâ‚ : Type} (Aâ‚‚ : Typeâ½áµ‰â¾ Aâ‚€ Aâ‚) {ğ‘¥â‚€ : Aâ‚€ â†’ Aâ‚€} {ğ‘¥â‚ : Aâ‚ â†’ Aâ‚}
         (ğ‘¥â‚‚ : {ğ‘¦â‚€ : Aâ‚€} {ğ‘¦â‚ : Aâ‚} (ğ‘¦â‚‚ : Aâ‚‚ ğ‘¦â‚€ ğ‘¦â‚) â†’â½áµ‰â¾ Aâ‚‚ (ğ‘¥â‚€ ğ‘¦â‚€) (ğ‘¥â‚ ğ‘¦â‚)) {ğ‘¦â‚€ : Aâ‚€}
         {ğ‘¦â‚ : Aâ‚} (ğ‘¦â‚‚ : Aâ‚‚ ğ‘¦â‚€ ğ‘¦â‚)
         â†’â½áµ‰â¾ Aâ‚‚ (ğ‘¥â‚€ (ğ‘¥â‚€ ğ‘¦â‚€)) (ğ‘¥â‚ (ğ‘¥â‚ ğ‘¦â‚))
       but is being checked against type
         {Aâ‚€ : Type} {Aâ‚ : Type} (Aâ‚‚ : Typeâ½áµ‰â¾ Aâ‚€ Aâ‚) {ğ‘¥â‚€ : Aâ‚€ â†’ Aâ‚€} {ğ‘¥â‚ : Aâ‚ â†’ Aâ‚}
         (ğ‘¥â‚‚ : {ğ‘¦â‚€ : Aâ‚€} {ğ‘¦â‚ : Aâ‚} (ğ‘¦â‚‚ : Aâ‚‚ ğ‘¦â‚€ ğ‘¦â‚) â†’â½áµ‰â¾ Aâ‚‚ (ğ‘¥â‚€ ğ‘¦â‚€) (ğ‘¥â‚ ğ‘¦â‚)) {ğ‘¦â‚€ : Aâ‚€}
         {ğ‘¦â‚ : Aâ‚} (ğ‘¦â‚‚ : Aâ‚‚ ğ‘¦â‚€ ğ‘¦â‚)
         â†’â½áµ‰â¾ Aâ‚‚ (ğ‘¥â‚€ (ğ‘¥â‚€ (ğ‘¥â‚€ ğ‘¦â‚€))) (ğ‘¥â‚ (ğ‘¥â‚ ğ‘¦â‚))
       unequal head variables:
         _H
       does not equal
         _H
  
  [1]
  $ narya constants.ny -e "def âˆeta_bisim' : Id (Stream A â†’ Stream A) (s â†¦ s) (s â†¦ âˆeta s) â‰” refl (s â†¦ âˆeta s)"
   ï¿« error[E0401]
   ï¿­ command-line exec string
   1 | def âˆeta_bisim' : Id (Stream A â†’ Stream A) (s â†¦ s) (s â†¦ âˆeta s) â‰” refl (s â†¦ âˆeta s)
     ^ term synthesized type
         {ğ‘¥â‚€ : Stream A} {ğ‘¥â‚ : Stream A} (ğ‘¥â‚‚ : Streamâ½áµ‰â¾ (Id A) ğ‘¥â‚€ ğ‘¥â‚)
         â†’â½áµ‰â¾ Streamâ½áµ‰â¾ (Id A) (âˆeta ğ‘¥â‚€) (âˆeta ğ‘¥â‚)
       but is being checked against type
         {ğ‘¥â‚€ : Stream A} {ğ‘¥â‚ : Stream A} (ğ‘¥â‚‚ : Streamâ½áµ‰â¾ (Id A) ğ‘¥â‚€ ğ‘¥â‚)
         â†’â½áµ‰â¾ Streamâ½áµ‰â¾ (Id A) ğ‘¥â‚€ (âˆeta ğ‘¥â‚)
       unequal head terms:
         âˆeta
       does not equal
         _H
  
  [1]
  $ narya constants.ny -e "def refl_nat_eq_sample : Id (â„• â†’ Id ((x:A)â†’B x) f f) (refl_nat_f) (refl_nat_f_cube) â‰” refl refl_nat_f"
   ï¿« error[E0401]
   ï¿­ command-line exec string
   1 | def refl_nat_eq_sample : Id (â„• â†’ Id ((x:A)â†’B x) f f) (refl_nat_f) (refl_nat_f_cube) â‰” refl refl_nat_f
     ^ term synthesized type
         {ğ‘¥â‚€ : â„•} {ğ‘¥â‚ : â„•} (ğ‘¥â‚‚ : â„•â½áµ‰â¾ ğ‘¥â‚€ ğ‘¥â‚)
         â†’â½áµ‰â¾ {xâ‚€â‚€ : A} {xâ‚€â‚ : A} {xâ‚€â‚‚ : Id A xâ‚€â‚€ xâ‚€â‚} {xâ‚â‚€ : A} {xâ‚â‚ : A}
              {xâ‚â‚‚ : Id A xâ‚â‚€ xâ‚â‚} {xâ‚‚â‚€ : Id A xâ‚€â‚€ xâ‚â‚€} {xâ‚‚â‚ : Id A xâ‚€â‚ xâ‚â‚}
              (xâ‚‚â‚‚ : Aâ½áµ‰áµ‰â¾ xâ‚€â‚‚ xâ‚â‚‚ xâ‚‚â‚€ xâ‚‚â‚)
              â†’â½áµ‰áµ‰â¾ Bâ½áµ‰áµ‰â¾ xâ‚‚â‚‚ (ap f xâ‚€â‚‚) (ap f xâ‚â‚‚) (refl_nat_f ğ‘¥â‚€ xâ‚‚â‚€)
                      (refl_nat_f ğ‘¥â‚ xâ‚‚â‚)
       but is being checked against type
         {ğ‘¥â‚€ : â„•} {ğ‘¥â‚ : â„•} (ğ‘¥â‚‚ : â„•â½áµ‰â¾ ğ‘¥â‚€ ğ‘¥â‚)
         â†’â½áµ‰â¾ {xâ‚€â‚€ : A} {xâ‚€â‚ : A} {xâ‚€â‚‚ : Id A xâ‚€â‚€ xâ‚€â‚} {xâ‚â‚€ : A} {xâ‚â‚ : A}
              {xâ‚â‚‚ : Id A xâ‚â‚€ xâ‚â‚} {xâ‚‚â‚€ : Id A xâ‚€â‚€ xâ‚â‚€} {xâ‚‚â‚ : Id A xâ‚€â‚ xâ‚â‚}
              (xâ‚‚â‚‚ : Aâ½áµ‰áµ‰â¾ xâ‚€â‚‚ xâ‚â‚‚ xâ‚‚â‚€ xâ‚‚â‚)
              â†’â½áµ‰áµ‰â¾ Bâ½áµ‰áµ‰â¾ xâ‚‚â‚‚ (ap f xâ‚€â‚‚) (ap f xâ‚â‚‚) (refl_nat_f ğ‘¥â‚€ xâ‚‚â‚€)
                      (refl_nat_f_cube ğ‘¥â‚ xâ‚‚â‚)
       unequal head constants:
         refl_nat_f
       does not equal
         refl_nat_f_cube
  
  [1]
