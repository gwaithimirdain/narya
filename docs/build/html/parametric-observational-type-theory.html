

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Parametric Observational Type Theory &mdash; Narya 0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=2709fde1"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Remarks on implementation" href="remarks.html" />
    <link rel="prev" title="Mutual definitions" href="mutual-definitions.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Narya
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="top-level-interface.html">Top level interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="built-in-types.html">Built-in types</a></li>
<li class="toctree-l1"><a class="reference internal" href="names-and-notations.html">Names and notations</a></li>
<li class="toctree-l1"><a class="reference internal" href="imports-and-scoping.html">Imports and scoping</a></li>
<li class="toctree-l1"><a class="reference internal" href="typechecking.html">Typechecking details</a></li>
<li class="toctree-l1"><a class="reference internal" href="interactive.html">Interactive proof</a></li>
<li class="toctree-l1"><a class="reference internal" href="record-types.html">Record types and tuples</a></li>
<li class="toctree-l1"><a class="reference internal" href="data-types.html">Inductive datatypes and matching</a></li>
<li class="toctree-l1"><a class="reference internal" href="codata-types.html">Codatatypes and comatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="canonical-types.html">Canonical types defined by case trees</a></li>
<li class="toctree-l1"><a class="reference internal" href="mutual-definitions.html">Mutual definitions</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Parametric Observational Type Theory</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#identity-bridge-types-of-canonical-types">Identity/bridge types of canonical types</a></li>
<li class="toctree-l2"><a class="reference internal" href="#identity-bridge-types-of-the-universe">Identity/bridge types of the universe</a></li>
<li class="toctree-l2"><a class="reference internal" href="#heterogeneous-identity-bridge-types">Heterogeneous identity/bridge types</a></li>
<li class="toctree-l2"><a class="reference internal" href="#higher-dimensional-cubes">Higher-dimensional cubes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#symmetries-and-degeneracies">Symmetries and degeneracies</a></li>
<li class="toctree-l2"><a class="reference internal" href="#implicit-boundaries">Implicit boundaries</a></li>
<li class="toctree-l2"><a class="reference internal" href="#cubes-of-variables">Cubes of variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="#varying-the-behavior-of-parametricity">Varying the behavior of parametricity</a></li>
<li class="toctree-l2"><a class="reference internal" href="#higher-datatypes-and-codatatypes">Higher datatypes and codatatypes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#displayed-coinductive-types">Displayed coinductive types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#higher-coinductive-types">Higher coinductive types</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#parametrically-discrete-types">Parametrically discrete types</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="remarks.html">Remarks on implementation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Narya</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Parametric Observational Type Theory</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/parametric-observational-type-theory.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="parametric-observational-type-theory">
<h1>Parametric Observational Type Theory<a class="headerlink" href="#parametric-observational-type-theory" title="Link to this heading"></a></h1>
<p>There are many ways in which a type theory can be “higher-dimensional”, by which we include homotopy type theory (specifically, Higher Observational Type Theory), internally parametric type theories, and <a class="reference external" href="https://arxiv.org/abs/2311.18781">displayed type theory</a>.  The internal architecture of Narya is set up to eventually permit the user to mix and match multiple such “directions” of higher-dimensionality, but currently this is not realized.  At the moment, therefore, there is only one built-in direction, although its behavior is somewhat customizable.  We will first describe the current default behavior of this direction, which is <em>binary internal parametricity</em>, and then how it can be modified.</p>
<section id="identity-bridge-types-of-canonical-types">
<h2>Identity/bridge types of canonical types<a class="headerlink" href="#identity-bridge-types-of-canonical-types" title="Link to this heading"></a></h2>
<p>Every type <code class="docutils literal notranslate"><span class="pre">A</span></code> has a binary identity/bridge type denoted <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">A</span> <span class="pre">x</span> <span class="pre">y</span></code>, and each term <code class="docutils literal notranslate"><span class="pre">x:A</span></code> has a reflexivity term <code class="docutils literal notranslate"><span class="pre">refl</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">Id</span> <span class="pre">A</span> <span class="pre">x</span> <span class="pre">x</span></code>.  (The argument of <code class="docutils literal notranslate"><span class="pre">refl</span></code> must synthesize.)  There is no built-in “transport” for these types (hence “bridge” is really a more appropriate name).  But they are “observational” in the sense that the identity/bridge type of a canonical type is another canonical type of the same sort.</p>
<p>For example, <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">(A</span> <span class="pre">→</span> <span class="pre">B)</span> <span class="pre">f</span> <span class="pre">g</span></code> is a function-type <code class="docutils literal notranslate"><span class="pre">(x₀</span> <span class="pre">x₁</span> <span class="pre">:</span> <span class="pre">A)</span> <span class="pre">(x₂</span> <span class="pre">:</span> <span class="pre">Id</span> <span class="pre">A</span> <span class="pre">x₀</span> <span class="pre">x₁)</span> <span class="pre">→</span> <span class="pre">Id</span> <span class="pre">B</span> <span class="pre">(f</span> <span class="pre">x₀)</span> <span class="pre">(g</span> <span class="pre">x₁)</span></code>.  In particular, <code class="docutils literal notranslate"><span class="pre">refl</span> <span class="pre">f</span></code> is a function of a type <code class="docutils literal notranslate"><span class="pre">(x₀</span> <span class="pre">x₁</span> <span class="pre">:</span> <span class="pre">A)</span> <span class="pre">(x₂</span> <span class="pre">:</span> <span class="pre">Id</span> <span class="pre">A</span> <span class="pre">x₀</span> <span class="pre">x₁)</span> <span class="pre">→</span> <span class="pre">Id</span> <span class="pre">B</span> <span class="pre">(f</span> <span class="pre">x₀)</span> <span class="pre">(f</span> <span class="pre">x₁)</span></code>, witnessing that all functions preserve “equalities” or “relatedness”.  Thus the operation traditionally denoted <code class="docutils literal notranslate"><span class="pre">ap</span></code> in homotopy type theory is just <code class="docutils literal notranslate"><span class="pre">refl</span></code> applied to a function (although since the argument of <code class="docutils literal notranslate"><span class="pre">refl</span></code> must synthesize, if the function is an abstraction it must be ascribed).  Similarly, <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">(A</span> <span class="pre">×</span> <span class="pre">B)</span> <span class="pre">u</span> <span class="pre">v</span></code> is a type of pairs of identities, so if we have <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">:</span> <span class="pre">Id</span> <span class="pre">A</span> <span class="pre">(u</span> <span class="pre">.fst)</span> <span class="pre">(v</span> <span class="pre">.fst)</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span> <span class="pre">:</span> <span class="pre">Id</span> <span class="pre">B</span> <span class="pre">(u</span> <span class="pre">.snd)</span> <span class="pre">(v</span> <span class="pre">.snd)</span></code> we can form <code class="docutils literal notranslate"><span class="pre">(p,q)</span> <span class="pre">:</span> <span class="pre">Id</span> <span class="pre">(A</span> <span class="pre">×</span> <span class="pre">B)</span> <span class="pre">u</span> <span class="pre">v</span></code>, and so on for other record types, datatypes, and codatatypes.</p>
<p>However, in Narya <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">(A</span> <span class="pre">→</span> <span class="pre">B)</span> <span class="pre">f</span> <span class="pre">g</span></code> does not <em>reduce</em> to the <em>ordinary</em> function-type <code class="docutils literal notranslate"><span class="pre">(x₀</span> <span class="pre">x₁</span> <span class="pre">:</span> <span class="pre">A)</span> <span class="pre">(x₂</span> <span class="pre">:</span> <span class="pre">Id</span> <span class="pre">A</span> <span class="pre">x₀</span> <span class="pre">x₁)</span> <span class="pre">→</span> <span class="pre">Id</span> <span class="pre">B</span> <span class="pre">(f</span> <span class="pre">x₀)</span> <span class="pre">(g</span> <span class="pre">x₁)</span></code>: instead it simply <em>behaves</em> like it, in the sense that its elements can be applied like functions and we can define elements of its as abstractions.  This should be compared with how <code class="docutils literal notranslate"><span class="pre">Covec</span> <span class="pre">A</span> <span class="pre">2</span></code> doesn’t reduce to <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">×</span> <span class="pre">(A</span> <span class="pre">×</span> <span class="pre">⊤)</span></code> but behaves like it in terms of what its elements are and what we can do with them.  In particular, <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">(A</span> <span class="pre">→</span> <span class="pre">B)</span> <span class="pre">f</span> <span class="pre">g</span></code> and <code class="docutils literal notranslate"><span class="pre">(x₀</span> <span class="pre">x₁</span> <span class="pre">:</span> <span class="pre">A)</span> <span class="pre">(x₂</span> <span class="pre">:</span> <span class="pre">Id</span> <span class="pre">A</span> <span class="pre">x₀</span> <span class="pre">x₁)</span> <span class="pre">→</span> <span class="pre">Id</span> <span class="pre">B</span> <span class="pre">(f</span> <span class="pre">x₀)</span> <span class="pre">(g</span> <span class="pre">x₁)</span></code> are definitionally isomorphic, with the functions in both directions being η-expansions <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">↦</span> <span class="pre">(x₀</span> <span class="pre">x₁</span> <span class="pre">x₂</span> <span class="pre">↦</span> <span class="pre">f</span> <span class="pre">x₀</span> <span class="pre">x₁</span> <span class="pre">x₂)</span></code>.  For most purposes this behavior is just as good as a reduction, and it retains more information about the type, which, as before, is useful for many purposes.  (In fact, with our current understanding, it appears to be <em>essential</em> for Narya’s normalization and typechecking algorithms.)</p>
<p>The same is true for other canonical types, e.g. <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">(A</span> <span class="pre">×</span> <span class="pre">B)</span> <span class="pre">u</span> <span class="pre">v</span></code> does not reduce to <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">A</span> <span class="pre">(u</span> <span class="pre">.fst)</span> <span class="pre">(v</span> <span class="pre">.fst)</span> <span class="pre">×</span> <span class="pre">Id</span> <span class="pre">B</span> <span class="pre">(u</span> <span class="pre">.snd)</span> <span class="pre">(v</span> <span class="pre">.snd)</span></code>, but it is <em>a</em> record type, with fields named <code class="docutils literal notranslate"><span class="pre">fst</span></code> and <code class="docutils literal notranslate"><span class="pre">snd</span></code>, that is definitionally isomorphic to it by η-expansions.  Similarly, identity types of codatatypes behave like types of bisimulations: <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">(Stream</span> <span class="pre">A)</span> <span class="pre">s</span> <span class="pre">t</span></code> is a codatatype that behaves as if it were defined by</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>codata [
| _ .head : Id A (s .head) (t .head)
| _ .tail : Id (Stream A) (s. tail) (t .tail)
]
</pre></div>
</div>
<p>Individual bisimulations, i.e. elements of <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">(Stream</span> <span class="pre">A)</span> <span class="pre">s</span> <span class="pre">t</span></code>, can then be constructed by comatching and corecursion.</p>
<p>In general, the fields, constructors, or methods of the identity/bridge type of a record type, datatype, or codatatype have the <em>same names</em> as those of the original type, and their types are the identity/bridge types of those of the original.</p>
<p>In the case of datatypes, the boundary (endpoints) of the identity/bridge type behave like <em>indices</em>.  Thus, for instance, <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">ℕ</span></code> behaves like an indexed datatype defined by</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>data [
| zero. : Id ℕ zero. zero.
| suc. : (n₀ n₁ : ℕ) (n₂ : Id ℕ n₀ n₁) → Id ℕ (suc. n₀) (suc. n₁)
]
</pre></div>
</div>
</section>
<section id="identity-bridge-types-of-the-universe">
<h2>Identity/bridge types of the universe<a class="headerlink" href="#identity-bridge-types-of-the-universe" title="Link to this heading"></a></h2>
<p>According to internal parametricity, we morally think of <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">Type</span> <span class="pre">A</span> <span class="pre">B</span></code> as being the type <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">→</span> <span class="pre">B</span> <span class="pre">→</span> <span class="pre">Type</span></code> of correspondences.  (We avoid the word “relation” since it erroneously suggests proposition-valued.)  However, according to the above principles, we should expect <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">Type</span> <span class="pre">A</span> <span class="pre">B</span></code> to only <em>behave</em> like <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">→</span> <span class="pre">B</span> <span class="pre">→</span> <span class="pre">Type</span></code>, in that we can apply its elements to a pair of arguments in <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> to get a type, and define its elements by similarly abstracting.</p>
<p>The first is literally true: given <code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">:</span> <span class="pre">Id</span> <span class="pre">Type</span> <span class="pre">A</span> <span class="pre">B</span></code> and <code class="docutils literal notranslate"><span class="pre">a:A</span></code>, <code class="docutils literal notranslate"><span class="pre">b:B</span></code> we have <code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">:</span> <span class="pre">Type</span></code>.  We refer to this as <em>instantiating</em> the higher-dimensional type <code class="docutils literal notranslate"><span class="pre">R</span></code>.  In fact, <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">A</span> <span class="pre">x</span> <span class="pre">y</span></code> itself is an instantiation, as we have <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">A</span> <span class="pre">:</span> <span class="pre">Id</span> <span class="pre">Type</span> <span class="pre">A</span> <span class="pre">A</span></code>, which moreover is really just a notational variant of <code class="docutils literal notranslate"><span class="pre">refl</span> <span class="pre">A</span></code>.</p>
<p>However, unlike a true function <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">→</span> <span class="pre">B</span> <span class="pre">→</span> <span class="pre">Type</span></code>, an element of <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">Type</span> <span class="pre">A</span> <span class="pre">B</span></code> cannot be “partially applied”: you cannot write <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">A</span> <span class="pre">a</span></code>.  But of course, you can η-expand it and write <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">↦</span> <span class="pre">Id</span> <span class="pre">A</span> <span class="pre">a</span> <span class="pre">x</span></code>.  (If there is demand, we might implement an automatic η-expansion of the former to the latter.)</p>
<p>For the second there is another wrinkle: we can define elements of <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">Type</span> <span class="pre">A</span> <span class="pre">B</span></code> by abstracting, but the body of the abstraction must be a <em>newly declared canonical type</em> rather than a pre-existing one.  This also seems to be essential to deal with symmetries (see below) in the normalization and typechecking algorithm.  Moreover, the current implementation allows this body to be a <em>record type</em> or <em>codatatype</em>, but not a <em>datatype</em>, and it does not permit other case tree operations in between such as pattern-matching.</p>
<p>For record types, there is a syntax that reflects this restriction: instead of the expected <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">y</span> <span class="pre">↦</span> <span class="pre">sig</span> <span class="pre">(⋯)</span></code> we write <code class="docutils literal notranslate"><span class="pre">sig</span> <span class="pre">x</span> <span class="pre">y</span> <span class="pre">↦</span> <span class="pre">(⋯)</span></code>, explicitly binding all the boundary variables as part of the record type syntax.  For example, here is the universal 1-dimensional record type, traditionally called “Gel”:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def Gel (A B : Type) (R : A → B → Type) : Id Type A B ≔ sig a b ↦ ( ungel : R a b )
</pre></div>
</div>
<p>For codatatypes, we simply use the ordinary syntax, but the “self” variable automatically becomes a cube variable of the appropriate dimension (see below).</p>
<p>We may allow more flexibility in the future, but in practice the current restrictions do not seem very onerous.  For most applications, the above “Gel” record type can simply be defined once and used everywhere, rather than declaring new higher-dimensional types all the time.  Note that because record-types satisfy η-conversion, <code class="docutils literal notranslate"><span class="pre">Gel</span> <span class="pre">A</span> <span class="pre">B</span> <span class="pre">R</span> <span class="pre">a</span> <span class="pre">b</span></code> is definitionally isomorphic to <code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">a</span> <span class="pre">b</span></code>.  Thus, <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">Type</span> <span class="pre">A</span> <span class="pre">B</span></code> contains <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">→</span> <span class="pre">B</span> <span class="pre">→</span> <span class="pre">Type</span></code> as a “retract up to definitional isomorphism”.  This appears to be sufficient for all applications of internal parametricity.  (<code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">Type</span></code> does not itself satisfy any η-conversion rule.)</p>
</section>
<section id="heterogeneous-identity-bridge-types">
<h2>Heterogeneous identity/bridge types<a class="headerlink" href="#heterogeneous-identity-bridge-types" title="Link to this heading"></a></h2>
<p>If <code class="docutils literal notranslate"><span class="pre">B</span> <span class="pre">:</span> <span class="pre">A</span> <span class="pre">→</span> <span class="pre">Type</span></code>, then <code class="docutils literal notranslate"><span class="pre">refl</span> <span class="pre">B</span> <span class="pre">x₀</span> <span class="pre">x₁</span> <span class="pre">x₂</span> <span class="pre">:</span> <span class="pre">Id</span> <span class="pre">Type</span> <span class="pre">(B</span> <span class="pre">x₀)</span> <span class="pre">(B</span> <span class="pre">x₁)</span></code>.  Thus, given <code class="docutils literal notranslate"><span class="pre">y₀</span> <span class="pre">:</span> <span class="pre">B</span> <span class="pre">x₀</span></code> and <code class="docutils literal notranslate"><span class="pre">y₁</span> <span class="pre">:</span> <span class="pre">B</span> <span class="pre">x₁</span></code>, we can instantiate this identification at them to obtain a type <code class="docutils literal notranslate"><span class="pre">refl</span> <span class="pre">B</span> <span class="pre">x₀</span> <span class="pre">x₁</span> <span class="pre">x₂</span> <span class="pre">y₀</span> <span class="pre">y₁</span></code>. of <em>heterogeneous</em> identifications/bridges relating <code class="docutils literal notranslate"><span class="pre">y₀</span></code> and <code class="docutils literal notranslate"><span class="pre">y₁</span></code> “along” or “over” <code class="docutils literal notranslate"><span class="pre">x₂</span></code>.  Since <code class="docutils literal notranslate"><span class="pre">Id</span></code> is a notational variant of <code class="docutils literal notranslate"><span class="pre">refl</span></code>, this type can also be written suggestively as <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">B</span> <span class="pre">x₀</span> <span class="pre">x₁</span> <span class="pre">x₂</span> <span class="pre">y₀</span> <span class="pre">y₁</span></code>.</p>
<p>Such heterogeneous identity/bridge types are used in the computation (up to definitional isomorphism) of identity/bridge types of <em>dependent</em> function types.  Specifically, <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">((x:A)</span> <span class="pre">→</span> <span class="pre">B</span> <span class="pre">x)</span> <span class="pre">f</span> <span class="pre">g</span></code> acts like a function-type <code class="docutils literal notranslate"><span class="pre">(x₀</span> <span class="pre">x₁</span> <span class="pre">:</span> <span class="pre">A)</span> <span class="pre">(x₂</span> <span class="pre">:</span> <span class="pre">Id</span> <span class="pre">A</span> <span class="pre">x₀</span> <span class="pre">x₁)</span> <span class="pre">→</span> <span class="pre">refl</span> <span class="pre">B</span> <span class="pre">x₀</span> <span class="pre">x₁</span> <span class="pre">x₂</span> <span class="pre">(f</span> <span class="pre">x₀)</span> <span class="pre">(g</span> <span class="pre">x₁)</span></code>.  They also appear in identity/bridge types of other canonical types, such as when one field of a record type depends on previous ones.  For instance, <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">(Σ</span> <span class="pre">A</span> <span class="pre">B)</span> <span class="pre">u</span> <span class="pre">v</span></code> behaves like a record type</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>sig (
  fst : Id A (u .fst) (v .fst),
  snd : refl B (u .fst) (v .fst) fst (u .snd) (v .snd),
)
</pre></div>
</div>
<p>More generally, since <code class="docutils literal notranslate"><span class="pre">Σ</span> <span class="pre">:</span> <span class="pre">(A</span> <span class="pre">:</span> <span class="pre">Type)</span> <span class="pre">(B</span> <span class="pre">:</span> <span class="pre">A</span> <span class="pre">→</span> <span class="pre">Type)</span> <span class="pre">→</span> <span class="pre">Type</span></code>, we have <code class="docutils literal notranslate"><span class="pre">refl</span> <span class="pre">Σ</span></code> whose type is isomorphic to</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(A₀ : Type) (A₁ : Type) (A₂ : Id Type A₀ A₁) (B₀ : A₀ → Type) (B₁ : A₁ → Type)
  (B₂ : refl ((X ↦ X → Type) : Type → Type) A₀ A₁ A₂ B₀ B₁)
  (u₀ : Σ A₀ B₀) (u₁ : Σ A₁ B₁) → Type
</pre></div>
</div>
<p>and <code class="docutils literal notranslate"><span class="pre">refl</span> <span class="pre">Σ</span> <span class="pre">A₀</span> <span class="pre">A₁</span> <span class="pre">A₂</span> <span class="pre">B₀</span> <span class="pre">B₁</span> <span class="pre">B₂</span> <span class="pre">u₀</span> <span class="pre">u₁</span></code> behaves like a record type</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>sig (
  fst : A₂ (u₀ .fst) (u₁ .fst),
  snd : B₂ (u₀ .fst) (u₁ .fst) fst (u₀ .snd) (u₁ .snd),
)
</pre></div>
</div>
<p>Here we have used the fact that the type of <code class="docutils literal notranslate"><span class="pre">B₂</span></code> is similarly isomorphic to</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(x₀ : A₀) (x₁ : A₁) (x₂ : A₂ x₀ x₁) (y₀ : B₀ x₀) (y₁ : B₁ x₁) → Type
</pre></div>
</div>
<p>The ascription in the type of <code class="docutils literal notranslate"><span class="pre">B₂</span></code> is necessary since the argument of <code class="docutils literal notranslate"><span class="pre">refl</span></code> must synthesize, which abstractions do not.  This can be annoying to write, so an alternative is to use the built-in constant <code class="docutils literal notranslate"><span class="pre">Π</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>B₂ : refl Π A₀ A₁ A₂ (x₀ ↦ Type) (x₁ ↦ Type) (x₀ x₁ x₂ ↦ refl Type) B₀ B₁
</pre></div>
</div>
<p>In particular, this is what Narya uses when printing higher-dimensional function-types (although it also uses cube variables, see below).</p>
</section>
<section id="higher-dimensional-cubes">
<h2>Higher-dimensional cubes<a class="headerlink" href="#higher-dimensional-cubes" title="Link to this heading"></a></h2>
<p>Iterating <code class="docutils literal notranslate"><span class="pre">Id</span></code> or <code class="docutils literal notranslate"><span class="pre">refl</span></code> multiple times produces higher-dimensional cube types and cubes.  For instance, since <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">A</span></code> acts like a function <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">→</span> <span class="pre">A</span> <span class="pre">→</span> <span class="pre">Type</span></code>, <em>its</em> identity type or reflexivity type <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">(Id</span> <span class="pre">A)</span></code> acts as a function-type</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(x₀₀ : A) (x₀₁ : A) (x₀₂ : Id A x₀₀ x₀₁)
  → (x₁₀ : A) (x₁₁ : A) (x₁₂ : Id A x₁₀ x₁₁)
  → (x₂₀ : Id A x₀₀ x₁₀) (x₂₁ : Id A x₀₁ x₁₁) → Type
</pre></div>
</div>
<p>We can view this as assigning to any boundary for a 2-dimensional square a type of fillers for that square.  Similarly, <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">(Id</span> <span class="pre">(Id</span> <span class="pre">A))</span></code> yields a type of 3-dumensional cubes, and so on.  Likewise, iterating <code class="docutils literal notranslate"><span class="pre">refl</span></code> on functions acts on these cubes: if <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">:</span> <span class="pre">A</span> <span class="pre">→</span> <span class="pre">B</span></code>, then</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>refl (refl f) : Id A a₀₀ a₀₁ a₀₂ a₁₀ a₁₁ a₁₂ a₂₀ a₂₁
  → Id B (f a₀₀) (f a₀₁) (refl f a₀₀ a₀₁ a₀₂) (f a₁₀) (f a₁₁) (refl f a₁₀ a₁₁ a₁₂)
           (refl f a₀₀ a₁₀ a₂₀) (refl f a₀₁ a₁₁ a₂₁)
</pre></div>
</div>
<p>More generally, just as any “1-dimensional type” <code class="docutils literal notranslate"><span class="pre">A₂</span> <span class="pre">:</span> <span class="pre">Id</span> <span class="pre">Type</span> <span class="pre">A₀</span> <span class="pre">A₁</span></code> can be instantiated at endpoints <code class="docutils literal notranslate"><span class="pre">a₀:A₀</span></code> and <code class="docutils literal notranslate"><span class="pre">a₁:A₁</span></code> to produce an ordinary (0-dimensional) type <code class="docutils literal notranslate"><span class="pre">A₂</span> <span class="pre">a₀</span> <span class="pre">a₁</span> <span class="pre">:</span> <span class="pre">Type</span></code>, any element <code class="docutils literal notranslate"><span class="pre">A₂₂</span> <span class="pre">:</span> <span class="pre">Id</span> <span class="pre">(Id</span> <span class="pre">Type)</span> <span class="pre">A₀₀</span> <span class="pre">A₀₁</span> <span class="pre">A₀₂</span> <span class="pre">A₁₀</span> <span class="pre">A₁₁</span> <span class="pre">A₁₂</span> <span class="pre">A₂₀</span> <span class="pre">A₂₁</span></code> can be instantiated at a “heterogeneous square boundary” consisting of</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>a₀₀ : A₀₀
a₀₁ : A₀₁
a₀₂ : A₀₂ a₀₀ a₀₁
a₁₀ : A₁₀
a₁₁ : A₁₁
a₁₂ : A₁₂ a₁₀ a₁₁
a₂₀ : A₂₀ a₀₀ a₁₀
a₂₁ : A₂₁ a₀₁ a₁₁
</pre></div>
</div>
<p>to obtain an ordinary 0-dimensional type <code class="docutils literal notranslate"><span class="pre">A₂₂</span> <span class="pre">a₀₀</span> <span class="pre">a₀₁</span> <span class="pre">a₀₂</span> <span class="pre">a₁₀</span> <span class="pre">a₁₁</span> <span class="pre">a₁₂</span> <span class="pre">a₂₀</span> <span class="pre">a₂₁</span></code> whose elements are “heterogeneous squares”.</p>
<p>We mentioned above that a 1-dimensional type cannot be “partially instantiated” such as <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">A</span> <span class="pre">a₀</span></code>.  A higher-dimensional type <em>can</em> be partially instantiated, but not arbitrarily: you must give exactly enough arguments to reduce it to a type of some specific lower dimension.  For a 2-dimensional type such as <code class="docutils literal notranslate"><span class="pre">A₂₂</span></code> above, this means that in addition to its full 0-dimensional instantiations such as <code class="docutils literal notranslate"><span class="pre">A₂₂</span> <span class="pre">a₀₀</span> <span class="pre">a₀₁</span> <span class="pre">a₀₂</span> <span class="pre">a₁₀</span> <span class="pre">a₁₁</span> <span class="pre">a₁₂</span> <span class="pre">a₂₀</span> <span class="pre">a₂₁</span></code>, it has partial 1-dimensional instantiations such as</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>A₂₂ a₀₀ a₀₁ a₀₂ a₁₀ a₁₁ a₁₂ : Id Type (A₂₀ a₀₀ a₁₀) (A₂₁ a₀₁ a₁₁)
</pre></div>
</div>
<p>Note that this has exactly the right type that it can be <em>further</em> instantiated by <code class="docutils literal notranslate"><span class="pre">a₂₀</span> <span class="pre">a₂₁</span></code> to produce a 0-dimensional type.  In fact, the fundamental operation is actually a “partial instantiation” that reduces the dimension by one; a “full instantiation” is just a sequence of these.</p>
</section>
<section id="symmetries-and-degeneracies">
<h2>Symmetries and degeneracies<a class="headerlink" href="#symmetries-and-degeneracies" title="Link to this heading"></a></h2>
<p>There is a symmetry operation <code class="docutils literal notranslate"><span class="pre">sym</span></code> that acts on at-least-two dimensional cubes, swapping or transposing the last two dimensions.  Like <code class="docutils literal notranslate"><span class="pre">refl</span></code>, if the argument of <code class="docutils literal notranslate"><span class="pre">sym</span></code> synthesizes, then the <code class="docutils literal notranslate"><span class="pre">sym</span></code> synthesizes a symmetrized type; but in this case the argument must synthesize a “2-dimensional” type.  (The need to be able to “detect” 2-dimensionality here is roughly what imposes the requirements on our normalization/typechecking algorithm mentioned above.)  In addition, unlike <code class="docutils literal notranslate"><span class="pre">refl</span></code>, an application of <code class="docutils literal notranslate"><span class="pre">sym</span></code> can also check if its argument does, since the type it is checked against can be “unsymmetrized” to obtain the necessary type for its argument to check against.</p>
<p>Combining versions of <code class="docutils literal notranslate"><span class="pre">refl</span></code> and <code class="docutils literal notranslate"><span class="pre">sym</span></code> yields arbitrary higher-dimensional “degeneracies” (from the BCH cube category).  There is also a generic syntax for such degeneracies, for example <code class="docutils literal notranslate"><span class="pre">M⁽²ᵉ¹⁾</span></code> or <code class="docutils literal notranslate"><span class="pre">M^(2e1)</span></code> where the superscript represents the degeneracy, with <code class="docutils literal notranslate"><span class="pre">e</span></code> denoting a degenerate dimension and nonzero digits denoting a permutation.  (The <code class="docutils literal notranslate"><span class="pre">e</span></code> stands for “equality”, since our <code class="docutils literal notranslate"><span class="pre">Id</span></code> is eventually intended to be the identity type of Higher Observational Type Theory.)  In the unlikely event you are working with dimensions greater than nine, you can separate multi-digit numbers and letters with a hyphen, e.g. <code class="docutils literal notranslate"><span class="pre">M⁽¹⁻²⁻³⁻⁴⁻⁵⁻⁶⁻⁷⁻⁸⁻⁹⁻¹⁰⁾</span></code> or <code class="docutils literal notranslate"><span class="pre">M^(0-1-2-3-4-5-6-7-8-9-10)</span></code>.  This notation can always synthesize if <code class="docutils literal notranslate"><span class="pre">M</span></code> does, while like <code class="docutils literal notranslate"><span class="pre">sym</span></code> it can also check if the degeneracy is a “pure permutation”, consisting only of digits without any <code class="docutils literal notranslate"><span class="pre">e</span></code> s.</p>
<p>Degeneracies can be extended by identities on the left and remain the same operation.  For instance, the two degeneracies taking a 1-dimensional object to a 2-dimensional one are denoted <code class="docutils literal notranslate"><span class="pre">1e</span></code> and <code class="docutils literal notranslate"><span class="pre">e1</span></code>, and of these <code class="docutils literal notranslate"><span class="pre">1e</span></code> can be written as simply <code class="docutils literal notranslate"><span class="pre">e</span></code> and coincides with ordinary <code class="docutils literal notranslate"><span class="pre">refl</span></code> applied to an object that happens to be 1-dimensional.  Similarly, the basic symmetry <code class="docutils literal notranslate"><span class="pre">sym</span></code> of a 3-dimensional object actually acts on the last two dimensions, so it coincides with the superscripted operation <code class="docutils literal notranslate"><span class="pre">132</span></code>.</p>
<p>A mnemonic for the names of permutation operators is that the permutation numbers indicate the motion of arguments.  For instance, if we have a 3-dimensional cube</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>a222 : Id (Id (Id A))
  a000 a001 a002 a010 a011 a012 a020 a021 a022
  a100 a101 a102 a110 a111 a112 a120 a121 a122
  a200 a201 a202 a210 a211 a212 a220 a221
</pre></div>
</div>
<p>then to work out the boundary of a permuted cube such as <code class="docutils literal notranslate"><span class="pre">a222⁽³¹²⁾</span></code>, consider the motion of the “axes” <code class="docutils literal notranslate"><span class="pre">a001</span></code>, <code class="docutils literal notranslate"><span class="pre">a010</span></code>, and <code class="docutils literal notranslate"><span class="pre">a100</span></code>.  The permutation notation <code class="docutils literal notranslate"><span class="pre">(312)</span></code> denotes the permutation sending 1 to 3, sending 2 to 1, and sending 3 to 2.  Therefore, the first axis <code class="docutils literal notranslate"><span class="pre">a001</span></code> moves to the position previously occupied by the third axis <code class="docutils literal notranslate"><span class="pre">a100</span></code>, the second axis <code class="docutils literal notranslate"><span class="pre">a010</span></code> moves to the position previously occupied by the first axis <code class="docutils literal notranslate"><span class="pre">a001</span></code>, and the third axis <code class="docutils literal notranslate"><span class="pre">a100</span></code> moves to the position previously occupied by the second axis <code class="docutils literal notranslate"><span class="pre">a010</span></code>.  This determines the motion of the other boundary faces (although not which of them end up symmetrized):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>a222⁽³¹²⁾ : A⁽ᵉᵉᵉ⁾
  a000 a010 a020 a100 a110 a120 a200 a210 a220
  a001 a011 a021 a101 a111 a121 a201 a211 a221
  a002 a012 (sym a022) a102 a112 (sym a122) (sym a202) (sym a212)
</pre></div>
</div>
<p>Degeneracy operations are functorial.  For pure symmetries, this means composing permutations.  For instance, the “Yang-Baxter equation” holds, equating <code class="docutils literal notranslate"><span class="pre">M⁽²¹³⁾⁽¹³²⁾⁽²¹³⁾</span></code> with <code class="docutils literal notranslate"><span class="pre">M⁽¹³²⁾⁽²¹³⁾⁽¹³²⁾</span></code>, as both reduce to <code class="docutils literal notranslate"><span class="pre">M⁽³²¹⁾</span></code>.  Reflexivities also compose with permutations in a fairly straightforward way, e.g. <code class="docutils literal notranslate"><span class="pre">M⁽¹ᵉ⁾⁽²¹⁾</span></code> reduces to <code class="docutils literal notranslate"><span class="pre">M^⁽ᵉ¹⁾</span></code>.</p>
<p>The principle that the identity/bridge types of a canonical type are again canonical types of the same sort applies also to symmetries and higher degeneracies of such types, with one exception.  To explain the exception, observe that ordinary canonical types are “intrinsically” 0-dimensional, and therefore any operations on them reduce to a “pure degeneracy” consisting entirely of <code class="docutils literal notranslate"><span class="pre">e</span></code> s, e.g. <code class="docutils literal notranslate"><span class="pre">M⁽ᵉᵉ⁾⁽²¹⁾</span></code> reduces to simply <code class="docutils literal notranslate"><span class="pre">M⁽ᵉᵉ⁾</span></code>.  These pure degeneracies of canonical types are again canonical types of the same form, as discussed for <code class="docutils literal notranslate"><span class="pre">Id</span></code> and <code class="docutils literal notranslate"><span class="pre">refl</span></code> above.  However, an intrinsically higher-dimensional canonical type like <code class="docutils literal notranslate"><span class="pre">Gel</span></code> admits some degeneracies that permute the intrinsic dimension with some of the additional dimensions; the simplest of these is <code class="docutils literal notranslate"><span class="pre">1e</span></code>.  These degeneracies of a higher-dimensional canonical type are <em>not</em> any longer canonical; but they are isomorphic to a canonical type by the action of a pure symmetry.</p>
<p>For instance, <code class="docutils literal notranslate"><span class="pre">Gel</span> <span class="pre">A</span> <span class="pre">B</span> <span class="pre">R</span></code> is a 1-dimensional type, belonging to <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">Type</span> <span class="pre">A</span> <span class="pre">B</span></code>.  Thus, we can form the 2-dimensional type <code class="docutils literal notranslate"><span class="pre">(Gel</span> <span class="pre">A</span> <span class="pre">B</span> <span class="pre">R)⁽ᵉ¹⁾</span></code>, and instantiate it using <code class="docutils literal notranslate"><span class="pre">a₂</span> <span class="pre">:</span> <span class="pre">Id</span> <span class="pre">A</span> <span class="pre">a₀</span> <span class="pre">a₁</span></code> and <code class="docutils literal notranslate"><span class="pre">b₂</span> <span class="pre">:</span> <span class="pre">Id</span> <span class="pre">B</span> <span class="pre">b₀</span> <span class="pre">b₁</span></code> and <code class="docutils literal notranslate"><span class="pre">r₀</span> <span class="pre">:</span> <span class="pre">R</span> <span class="pre">a₀</span> <span class="pre">b₀</span></code> and <code class="docutils literal notranslate"><span class="pre">r₁</span> <span class="pre">:</span> <span class="pre">R</span> <span class="pre">a₁</span> <span class="pre">b₁</span></code> to get a 0-dimensional type <code class="docutils literal notranslate"><span class="pre">(Gel</span> <span class="pre">A</span> <span class="pre">B</span> <span class="pre">R)⁽ᵉ¹⁾</span> <span class="pre">a₀</span> <span class="pre">b₀</span> <span class="pre">(r₀,)</span> <span class="pre">a₁</span> <span class="pre">b₁</span> <span class="pre">(r₁,)</span> <span class="pre">a₂</span> <span class="pre">b₂</span></code>.  But this type is not canonical, and in particular not a record type; in particular given <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">:</span> <span class="pre">(Gel</span> <span class="pre">A</span> <span class="pre">B</span> <span class="pre">R)⁽ᵉ¹⁾</span> <span class="pre">a₀</span> <span class="pre">b₀</span> <span class="pre">(r₀,)</span> <span class="pre">a₁</span> <span class="pre">b₁</span> <span class="pre">(r₁,)</span> <span class="pre">a₂</span> <span class="pre">b₂</span></code> we cannot write <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">.ungel</span></code>.  However, we have <code class="docutils literal notranslate"><span class="pre">sym</span> <span class="pre">M</span> <span class="pre">:</span> <span class="pre">(Gel</span> <span class="pre">A</span> <span class="pre">B</span> <span class="pre">R)⁽¹ᵉ⁾</span> <span class="pre">a₀</span> <span class="pre">a₁</span> <span class="pre">a₂</span> <span class="pre">b₀</span> <span class="pre">b₁</span> <span class="pre">b₂</span> <span class="pre">(r₀,)</span> <span class="pre">(r₁,)</span></code>, which doesn’t permute the intrinsic dimension <code class="docutils literal notranslate"><span class="pre">1</span></code> with the degenerate dimension <code class="docutils literal notranslate"><span class="pre">e</span></code> and <em>is</em> therefore a record type, and so we can write <code class="docutils literal notranslate"><span class="pre">sym</span> <span class="pre">M</span> <span class="pre">.ungel</span></code>, which has type <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">R</span> <span class="pre">a₀</span> <span class="pre">a₁</span> <span class="pre">a₂</span> <span class="pre">b₀</span> <span class="pre">b₁</span> <span class="pre">b₂</span> <span class="pre">r₀</span> <span class="pre">r₁</span></code>.  In addition, since <code class="docutils literal notranslate"><span class="pre">(Gel</span> <span class="pre">A</span> <span class="pre">B</span> <span class="pre">R)⁽ᵉ¹⁾</span> <span class="pre">a₀</span> <span class="pre">b₀</span> <span class="pre">(r₀,)</span> <span class="pre">a₁</span> <span class="pre">b₁</span> <span class="pre">(r₁,)</span> <span class="pre">a₂</span> <span class="pre">b₂</span></code> is <em>isomorphic</em> to this record type, it also satisfies an eta-rule: two of its terms <code class="docutils literal notranslate"><span class="pre">M</span></code> and <code class="docutils literal notranslate"><span class="pre">N</span></code> are definitionally equal as soon as <code class="docutils literal notranslate"><span class="pre">sym</span> <span class="pre">M</span> <span class="pre">.ungel</span></code> and <code class="docutils literal notranslate"><span class="pre">sym</span> <span class="pre">N</span> <span class="pre">.ungel</span></code> are.</p>
</section>
<section id="implicit-boundaries">
<h2>Implicit boundaries<a class="headerlink" href="#implicit-boundaries" title="Link to this heading"></a></h2>
<p>Until now we have been writing all the arguments of higher-dimensional types and functions explicitly.  There are times when this is necessary, but it is clear that in many cases it is redundant.  For instance, in <code class="docutils literal notranslate"><span class="pre">refl</span> <span class="pre">f</span> <span class="pre">a₀</span> <span class="pre">a₁</span> <span class="pre">a₂</span></code>, since the type of <code class="docutils literal notranslate"><span class="pre">a₂</span></code> must be <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">A</span> <span class="pre">a₀</span> <span class="pre">a₁</span></code>, if we know this type (that is, if <code class="docutils literal notranslate"><span class="pre">a₂</span></code> synthesizes) then <code class="docutils literal notranslate"><span class="pre">a₀</span></code> and <code class="docutils literal notranslate"><span class="pre">a₁</span></code> are uniquely determined.</p>
<p>In general, this is the sort of issue that implicit arguments and higher-order unification are designed to deal with.  Narya does not yet have either of these features in general, but it does have a specialized version that essentially uses bidirectional typechecking to synthesize the redundant parts of boundaries in higher-dimensional function applications and type instantiations.  This feature is currently off by default; it can be turned on with the two commands</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>option function boundaries ≔ implicit
option type boundaries ≔ implicit
</pre></div>
</div>
<p>(and back off again with the similar <code class="docutils literal notranslate"><span class="pre">≔</span> <span class="pre">explicit</span></code> commands).</p>
<p>When <em>function</em> boundaries are implicit, a higher-dimensional function application takes only <em>one</em> argument, the top-dimensional one; thus instead of <code class="docutils literal notranslate"><span class="pre">refl</span> <span class="pre">f</span> <span class="pre">a₀</span> <span class="pre">a₁</span> <span class="pre">a₂</span></code> you can (and must) write <code class="docutils literal notranslate"><span class="pre">refl</span> <span class="pre">f</span> <span class="pre">a₂</span></code>, and instead of <code class="docutils literal notranslate"><span class="pre">refl</span> <span class="pre">(refl</span> <span class="pre">f)</span> <span class="pre">a₀₀</span> <span class="pre">a₀₁</span> <span class="pre">a₀₂</span> <span class="pre">a₁₀</span> <span class="pre">a₁₁</span> <span class="pre">a₁₂</span> <span class="pre">a₂₀</span> <span class="pre">a₂₁</span> <span class="pre">a₂₂</span></code> you can (and must) write <code class="docutils literal notranslate"><span class="pre">refl</span> <span class="pre">f</span> <span class="pre">a₂₂</span></code>.  It is possible to give the implicit arguments explicitly by surrounding them with curly braces, as in <code class="docutils literal notranslate"><span class="pre">refl</span> <span class="pre">f</span> <span class="pre">{a₀}</span> <span class="pre">{a₁}</span> <span class="pre">a₂</span></code>, but if you do this you must give <em>all</em> of them explicitly; there are no half measures.  The main reason you might need to do this is if <code class="docutils literal notranslate"><span class="pre">a₂</span></code> is a term that doesn’t synthesize, since in that case <code class="docutils literal notranslate"><span class="pre">refl</span> <span class="pre">f</span> <span class="pre">a₂</span></code> won’t be able to infer the boundaries <code class="docutils literal notranslate"><span class="pre">a₀</span></code> and <code class="docutils literal notranslate"><span class="pre">a₁</span></code>.</p>
<p>When <em>type</em> boundaries are implicit, a full instantiation of a higher-dimensional type takes only the <em>highest-dimensional</em> arguments.  For ordinary 1-dimensional identity types, this changes nothing, since both arguments <code class="docutils literal notranslate"><span class="pre">a₀</span></code> and <code class="docutils literal notranslate"><span class="pre">a₁</span></code> of <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">A</span> <span class="pre">a₀</span> <span class="pre">a₁</span></code> are 0-dimensional and that is the highest dimension of any argument.  But for squares, instead of <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">(Id</span> <span class="pre">A)</span> <span class="pre">a₀₀</span> <span class="pre">a₀₁</span> <span class="pre">a₀₂</span> <span class="pre">a₁₀</span> <span class="pre">a₁₁</span> <span class="pre">a₁₂</span> <span class="pre">a₂₀</span> <span class="pre">a₂₁</span></code> you can (and must) write <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">(Id</span> <span class="pre">A)</span> <span class="pre">a₀₂</span> <span class="pre">a₁₂</span> <span class="pre">a₂₀</span> <span class="pre">a₂₁</span></code> since these are the four 1-dimensional arguments; the 0-dimensional ones are inferred from their boundaries (which are required to match up correctly where they overlap).  And you can of course give them explicitly with <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">(Id</span> <span class="pre">A)</span> <span class="pre">{a₀₀}</span> <span class="pre">{a₀₁}</span> <span class="pre">a₀₂</span> <span class="pre">{a₁₀}</span> <span class="pre">{a₁₁}</span> <span class="pre">a₁₂</span> <span class="pre">a₂₀</span> <span class="pre">a₂₁</span></code>.  In this case there are some half measures: if you give any lower-dimensional argument explicitly you must give all the arguments in that “block” explictly, but you can omit those in other blocks; for instance you can write <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">(Id</span> <span class="pre">A)</span> <span class="pre">{a₀₀}</span> <span class="pre">{a₀₁}</span> <span class="pre">a₀₂</span> <span class="pre">a₁₂</span> <span class="pre">a₂₀</span> <span class="pre">a₂₁</span></code> or <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">(Id</span> <span class="pre">A)</span> <span class="pre">a₀₂</span> <span class="pre">{a₁₀}</span> <span class="pre">{a₁₁}</span> <span class="pre">a₁₂</span> <span class="pre">a₂₀</span> <span class="pre">a₂₁</span></code>.</p>
<p>Normally, when boundaries are implicit, Narya also <em>prints</em> higher-dimensional function applications and type instantiations with the lower-dimensional boundaries omitted.  However, you can tell it to print these arguments explicitly with the commands</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>display function boundaries ≔ on
display type boundaries ≔ on
</pre></div>
</div>
<p>(and switch back with <code class="docutils literal notranslate"><span class="pre">≔</span> <span class="pre">off</span></code>).  These commands are not available in source files, since they should not be un-done; they can be given in interactive mode, or in ProofGeneral with <code class="docutils literal notranslate"><span class="pre">C-c</span> <span class="pre">C-v</span></code>, or you can use the corresponding command-line flags such as <code class="docutils literal notranslate"><span class="pre">-show-function-boundaries</span></code>.  When these options are <code class="docutils literal notranslate"><span class="pre">on</span></code> <em>and</em> implicitness for the relevant kinds of boundaries is also on, Narya prints <em>all</em> the lower-dimensional arguments explicitly, with curly braces around them.  There are no half measures here, for functions or for types.  In the future, we may implement a way to switch on such display for some constants and/or variables but not others.</p>
<p>In addition, even when printing implicit boundaries is off, Narya attempts to be smart and print those boundaries when it thinks that they would be necessary in order to re-parse the printed term, because the corresponding explicit argument isn’t synthesizing.  In this case it can do half measures, the way you can when writing type boundaries: the implicit arguments in each “block” are printed only if the primary argument of that block is nonsynthesizing.</p>
</section>
<section id="cubes-of-variables">
<h2>Cubes of variables<a class="headerlink" href="#cubes-of-variables" title="Link to this heading"></a></h2>
<p>Implicitness of arguments to higher-dimensional <em>applications</em> has no bearing on higher-dimensional <em>abstractions</em>: the “implicit arguments” still must be named in an abstraction in the usual way, regardless of whether implicitness is on or not.  (This will also be Narya’s approach to implicit arguments more generally.)  However, there is a different shorthand syntax for higher-dimensional abstractions: instead of <code class="docutils literal notranslate"><span class="pre">x₀</span> <span class="pre">x₁</span> <span class="pre">x₂</span> <span class="pre">↦</span> <span class="pre">M</span></code> you can write <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">⤇</span> <span class="pre">M</span></code> (or <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">|=&gt;</span> <span class="pre">M</span></code> in ASCII).  This binds <code class="docutils literal notranslate"><span class="pre">x</span></code> as a “family” or “cube” of variables whose names are suffixed with face names in ternary notation: <code class="docutils literal notranslate"><span class="pre">x.0</span></code> and <code class="docutils literal notranslate"><span class="pre">x.1</span></code> and <code class="docutils literal notranslate"><span class="pre">x.2</span></code>, or in higher dimensions <code class="docutils literal notranslate"><span class="pre">x.00</span></code> through <code class="docutils literal notranslate"><span class="pre">x.22</span></code> and so on.  (The dimension is inferred from the type at which the abstraction is checked.)  Note that this is a <em>purely syntactic</em> abbreviation: there is no object “<code class="docutils literal notranslate"><span class="pre">x</span></code>”, but rather there are really <em>three different variables</em> that just happen to have the names <code class="docutils literal notranslate"><span class="pre">x.0</span></code> and <code class="docutils literal notranslate"><span class="pre">x.1</span></code> and <code class="docutils literal notranslate"><span class="pre">x.2</span></code>.  (There is no potential for collision with user-defined names, since ordinary local variable names cannot contain internal periods.  Of course, <code class="docutils literal notranslate"><span class="pre">x.0</span></code> can shadow a global definition of a constant <code class="docutils literal notranslate"><span class="pre">0</span></code> in namespace <code class="docutils literal notranslate"><span class="pre">x</span></code>.)</p>
<p>These “cube variables” also appear automatically when matching against a higher-dimensional version of a datatype.  For instance, we can do an encode-decode proof for the natural numbers by matching directly on <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">ℕ</span></code> (using pattern-matching abstractions):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def code : ℕ → ℕ → Type ≔
[ zero. ↦ [ zero. ↦ sig ()
          | suc. n ↦ data [] ]
| suc. m ↦ [ zero. ↦ data []
           | suc. n ↦ sig ( uncode : code m n ) ]]

def decode : (m n : ℕ) → code m n → Id ℕ m n ≔
[ zero. ↦ [ zero. ↦ _ ↦ zero.
          | suc. n ↦ [] ]
| suc. m ↦ [ zero. ↦ []
           | suc. n ↦ p ↦ suc. (decode m n (p .0)) ]]

def encode (m n : ℕ) : Id ℕ m n → code m n ≔
[ zero. ↦ ()
| suc. p ↦ (_ ≔ encode p.0 p.1 p.2)]
</pre></div>
</div>
<p>Here in the definition of <code class="docutils literal notranslate"><span class="pre">encode</span></code>, the pattern variable <code class="docutils literal notranslate"><span class="pre">p`</span> <span class="pre">of</span> <span class="pre">the</span> <span class="pre">``suc.</span></code> branch is automatically made into a 1-dimensional cube of variables since we are matching against an element of <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">ℕ</span></code>, so in the body we can refer to <code class="docutils literal notranslate"><span class="pre">p.0</span></code>, <code class="docutils literal notranslate"><span class="pre">p.1</span></code>, and <code class="docutils literal notranslate"><span class="pre">p.2</span></code>.  In the future, we may implement a dual syntax for simultaneously <em>applying</em> a higher-dimensional function to a whole cube of variables of this sort as well, although of course if implicit application is on you can just write <code class="docutils literal notranslate"><span class="pre">refl</span> <span class="pre">f</span> <span class="pre">x.2</span></code> and so on.</p>
<p>Similarly, when defining a codatatype lying in a higher universe, the “self” variable automatically becomes a cube variable, so that the boundary of the type is accessible through its faces.  For instance, here is a codatatype version of Gel:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def Gel (A B : Type) (R : A → B → Type) : Id Type A B ≔ codata [ x .ungel : R x.0 x.1 ]
</pre></div>
</div>
</section>
<section id="varying-the-behavior-of-parametricity">
<h2>Varying the behavior of parametricity<a class="headerlink" href="#varying-the-behavior-of-parametricity" title="Link to this heading"></a></h2>
<p>The parametricity described above, which is Narya’s default, is <em>binary</em> in that the identity/bridge type <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">A</span> <span class="pre">x</span> <span class="pre">y</span></code> takes <em>two</em> elements of <code class="docutils literal notranslate"><span class="pre">A</span></code> as arguments.  However, a different “arity” can be specified with the <code class="docutils literal notranslate"><span class="pre">-arity</span></code> command-line flag.  For instance, under <code class="docutils literal notranslate"><span class="pre">-arity</span> <span class="pre">1</span></code> we have bridge types <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">A</span> <span class="pre">x</span></code>, and under <code class="docutils literal notranslate"><span class="pre">-arity</span> <span class="pre">3</span></code> they look like <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">A</span> <span class="pre">x</span> <span class="pre">y</span> <span class="pre">z</span></code>.  Everything else also alters according, e.g. under <code class="docutils literal notranslate"><span class="pre">-arity</span> <span class="pre">1</span></code> the type <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">(A</span> <span class="pre">→</span> <span class="pre">B)</span> <span class="pre">f</span></code> is isomorphic to <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">:</span> <span class="pre">A)</span> <span class="pre">(x'</span> <span class="pre">:</span> <span class="pre">Id</span> <span class="pre">A</span> <span class="pre">x)</span> <span class="pre">→</span> <span class="pre">Id</span> <span class="pre">B</span> <span class="pre">(f</span> <span class="pre">x)</span></code>, and a cube variable has pieces numbered with only <code class="docutils literal notranslate"><span class="pre">0</span></code> s and <code class="docutils literal notranslate"><span class="pre">1</span></code> s.</p>
<p>In principle, the arity could be any natural number, but for syntactic reasons Narya currently requires it to be between 1 and 9 inclusive.  The problem with arities greater than 9 is that the syntax <code class="docutils literal notranslate"><span class="pre">x.10</span></code> for cube variables would become ambiguous: does <code class="docutils literal notranslate"><span class="pre">10</span></code> mean “one-zero” or “ten”?  But if you have an application of such a type theory, let us know and we can work out a syntax (although at present we are unaware of any applications of n-ary parametricity for n&gt;2).  The problem with arity 0 is that then <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">A</span></code> would belong to <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">Type</span></code> and also be instantiatable to an element of <code class="docutils literal notranslate"><span class="pre">Type</span></code>, but since this requires no arguments it’s not clear what syntax should indicate whether the instantiation has happened.  We do expect to solve this problem somehow, since 0-ary parametricity does have potential applications (it is related to nominal type theory).</p>
<p>It is also possible to rename or remove the primitives <code class="docutils literal notranslate"><span class="pre">refl</span></code> and <code class="docutils literal notranslate"><span class="pre">Id</span></code> (which, recall, is just another notation for <code class="docutils literal notranslate"><span class="pre">refl</span></code>), as well as change the letter <code class="docutils literal notranslate"><span class="pre">e</span></code> used in generic degeneracies.  The default behavior is equivalent to the command-line argument <code class="docutils literal notranslate"><span class="pre">-direction</span> <span class="pre">e,refl,Id</span></code>; in general the argument of <code class="docutils literal notranslate"><span class="pre">-direction</span></code> is a comma-separated list of names, where the first must be a single lowercase letter to be used in generic degeneracies, and the others (if any) are names for the basic degeneracy.  For instance, in unary parametricity we might write <code class="docutils literal notranslate"><span class="pre">-arity</span> <span class="pre">1</span> <span class="pre">-direction</span> <span class="pre">r,red</span></code> and think of <code class="docutils literal notranslate"><span class="pre">red</span> <span class="pre">x</span></code> as “<code class="docutils literal notranslate"><span class="pre">x</span></code> is reducible”.</p>
<p>The name of <code class="docutils literal notranslate"><span class="pre">sym</span></code> cannot be changed or removed, and likewise for the digits used in generic degeneracies to indicate permuted dimensions.</p>
<p>Finally, parametricity can be set to be <em>internal</em> (the default) or <em>external</em>.  Setting it to external instead means that dimension-changing degeneracies (including <code class="docutils literal notranslate"><span class="pre">refl</span></code>, but not <code class="docutils literal notranslate"><span class="pre">sym</span></code>) can only be applied to <em>closed terms</em>.  Since degeneracies also compute fully on closed terms (at least in the “up-to-definitional-isomorphism” sense), we can then more or less think of these operations as meta-operations on syntax rather than intrinsic aspects of the theory.  This is the usual meaning of “external parametricity”, although Narya’s is of course at least partially internalized.  (Semantically, what Narya calls “external parametricity” is modeled in a diagram of <em>semi-cubical</em> types, in contrast to internal parametricity which is modeled in <em>cubical</em> types.)</p>
<p>In addition, under external parametricity, <em>axioms</em> are not permitted to be used inside of dimension-changing degeneracies either.  The reasoning behind this is that we may want to assume axioms that are inconsistent with parametricity, such as excluded middle, while still making use of external parametricity on other types.  (Note that <em>internal</em> parametricity is nonclassical, actively contradicting excluded middle.)  It also maintains the principle that assuming an axiom of type <cite>A</cite> is equivalent to working in a context extended by a variable of type <cite>A</cite>.  However, in the future it may be possible to declare a special kind of “parametric axiom” that does have higher-dimensional versions.</p>
<p>The combination <code class="docutils literal notranslate"><span class="pre">-arity</span> <span class="pre">1</span> <span class="pre">-direction</span> <span class="pre">d</span> <span class="pre">-external</span></code> is a version of <a class="reference external" href="https://arxiv.org/abs/2311.18781">displayed type theory</a> (dTT), and as such can be selected with the single option <code class="docutils literal notranslate"><span class="pre">-dtt</span></code>.  The primary differences between <code class="docutils literal notranslate"><span class="pre">narya</span> <span class="pre">-dtt</span></code> and the original dTT of the paper are:</p>
<ol class="arabic simple">
<li><p>Narya currently has no modalities, so display can only be applied to closed terms rather than to the more general □-modal ones.</p></li>
<li><p>Narya has symmetries, which in particular (as noted in the paper) makes <code class="docutils literal notranslate"><span class="pre">SST⁽ᵈ⁾</span></code> (see below) actually usable.</p></li>
<li><p>As noted above, display in Narya computes only up to isomorphism, and in the case of <code class="docutils literal notranslate"><span class="pre">Type</span></code> only up to retract up to isomorphism.</p></li>
<li><p>(A syntactic difference only) Generic degeneracies in Narya must be parenthesized, so we write <code class="docutils literal notranslate"><span class="pre">A⁽ᵈ⁾</span></code> instead of <code class="docutils literal notranslate"><span class="pre">Aᵈ</span></code>.</p></li>
</ol>
</section>
<section id="higher-datatypes-and-codatatypes">
<h2>Higher datatypes and codatatypes<a class="headerlink" href="#higher-datatypes-and-codatatypes" title="Link to this heading"></a></h2>
<p>There are many possible kinds of datatypes and codatatypes that make use of higher-dimensional structure.</p>
<section id="displayed-coinductive-types">
<h3>Displayed coinductive types<a class="headerlink" href="#displayed-coinductive-types" title="Link to this heading"></a></h3>
<p>In the <em>displayed coinductive types</em> of dTT, the <em>output</em> of a corecursive method is a higher-dimensional version of the codatatype.  One of the most basic examples is the definition of the type of semi-simplicial types from the dTT paper:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def SST : Type ≔ codata [
| X .z : Type
| X .s : (X .z) → SST⁽ᵈ⁾ X
]
</pre></div>
</div>
<p>Narya permits displayed coinductives and their generalization to other kinds of parametricity.  Some examples can be found in the test directory <code class="docutils literal notranslate"><span class="pre">test/black/dtt.t</span></code>.</p>
</section>
<section id="higher-coinductive-types">
<h3>Higher coinductive types<a class="headerlink" href="#higher-coinductive-types" title="Link to this heading"></a></h3>
<p>By a “higher coinductive type” we mean a codatatype in which the <em>input</em> of a method is a higher-dimensional version of itself, dually to how a “higher inductive type” has constructors whose <em>output</em> is a higher-dimensional version of itself.  The simplest example of a higher coinductive type is the “amazing right adjoint” of the identity type.  Applied to a concrete type like <code class="docutils literal notranslate"><span class="pre">ℕ</span></code>, this has the Narya syntax:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def √ℕ : Type ≔ codata [
| x .root.e : ℕ
]
</pre></div>
</div>
<p>Recall that a field name cannot contain internal periods.  This may appear to be an exception, but in fact the real name of the field here is actually just <code class="docutils literal notranslate"><span class="pre">root</span></code>.  The suffix <code class="docutils literal notranslate"><span class="pre">e</span></code> is a marker indicating that it is a 1-dimensional field (when <code class="docutils literal notranslate"><span class="pre">e</span></code> is the direction letter, as in the default configuration).  The argument <code class="docutils literal notranslate"><span class="pre">x</span></code> of this field is therefore a 1-dimensional “cube variable”, as we can see by leaving a hole instead:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def √ℕ : Type ≔ codata [
| x .root.e : ?
]

 ￫ info[I0100]
 ￮ hole ?0 generated:

   x.0 : √ℕ
   x.1 : √ℕ
   x.2 : refl √ℕ x.0 x.1
   ----------------------------------------------------------------------
   Type
</pre></div>
</div>
<p>Unsurprisingly, therefore, the field <code class="docutils literal notranslate"><span class="pre">root</span></code> can only be projected out of a higher-dimensional inhabitant of <code class="docutils literal notranslate"><span class="pre">√ℕ</span></code>.  If we try to project it out of an ordinary element we get an error:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>axiom x : √ℕ
echo x .root

  ￫ error[E0801]
 1 | x .root
   ^ codata type √A has no field named root
</pre></div>
</div>
<p>The syntax for using a higher field is different from the syntax for defining it, however.  In the simplest case, when projecting from a 1-dimensional element, we replace the suffix <code class="docutils literal notranslate"><span class="pre">e</span></code> by <code class="docutils literal notranslate"><span class="pre">1</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>axiom x : √ℕ
axiom y : √ℕ
axiom z : Id √ℕ x y
echo z .root.1

z .root.1
  : ℕ
</pre></div>
</div>
<p>Just as the higher-dimensional versions of an ordinary codatatype inherit fields of the same name, the same is true for higher codatatypes, but with a twist.  Namely, a 1-dimensional field like <code class="docutils literal notranslate"><span class="pre">root</span></code> induces <em>two</em> fields that can be projected out of a 2-dimensional version of <code class="docutils literal notranslate"><span class="pre">√ℕ</span></code>, corresponding to the two directions of a square, and these are distinguished by different numerical suffixes.  For example, if we have</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>x22 : √ℕ⁽ᵉᵉ⁾ x00 x01 x02 x10 x11 x12 x20 x21
</pre></div>
</div>
<p>with <code class="docutils literal notranslate"><span class="pre">x00</span></code> through <code class="docutils literal notranslate"><span class="pre">x21</span></code> of appropriate types, then the two projectable fields of <code class="docutils literal notranslate"><span class="pre">x22</span></code> and their types are</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>x22 .root.1 : refl A (x20 .root.1) (x21 .root.1)
x22 .root.2 : refl A (x02 .root.1) (x12 .root.1)
</pre></div>
</div>
<p>Unsurprisingly, these two fields are related by symmetry: <code class="docutils literal notranslate"><span class="pre">x22</span> <span class="pre">.root.2</span></code> is equal to <code class="docutils literal notranslate"><span class="pre">(sym</span> <span class="pre">x22)</span> <span class="pre">.root.1</span></code> and vice versa.  To implement this equality, in fact <code class="docutils literal notranslate"><span class="pre">x22</span> <span class="pre">.root.2</span></code> computes to <code class="docutils literal notranslate"><span class="pre">(sym</span> <span class="pre">x22)</span> <span class="pre">.root.1</span></code>.  (I don’t know of a principled reason for a computation of this sort to go in one direction rather than the other; the present direction was just easier to implement.)  Recall also that <code class="docutils literal notranslate"><span class="pre">sym</span> <span class="pre">x⁽ᵉᵉ⁾</span> <span class="pre">=</span> <span class="pre">x⁽ᵉᵉ⁾</span></code>, from which it follows that <code class="docutils literal notranslate"><span class="pre">x⁽ᵉᵉ⁾</span> <span class="pre">.root.1</span> <span class="pre">=</span> <span class="pre">x⁽ᵉᵉ⁾</span> <span class="pre">.root.2</span></code>.</p>
<p>In general, a 1-dimensional field like <code class="docutils literal notranslate"><span class="pre">root</span></code> induces <em>n</em> fields of an <em>n</em>-dimenional version of a higher codatatype, distinguished by numerical suffixes from 1 to <em>n</em>. A 2-dimensional field, defined in the <code class="docutils literal notranslate"><span class="pre">codata</span></code> declaration as <code class="docutils literal notranslate"><span class="pre">.field.ee</span></code>, induces (<em>n</em>)(<em>n</em>-1) fields of the <em>n</em>-dimensional version of the type, distinguished by numerical suffixes consisting of pairs of digits each from 1 to <em>n</em>. For instance, when <a href="#id2"><span class="problematic" id="id3">*</span></a>n*=3 the six fields are <code class="docutils literal notranslate"><span class="pre">.field.12</span></code>, <code class="docutils literal notranslate"><span class="pre">.field.13</span></code>, <code class="docutils literal notranslate"><span class="pre">.field.23</span></code>, <code class="docutils literal notranslate"><span class="pre">.field.21</span></code>, <code class="docutils literal notranslate"><span class="pre">.field.32</span></code>, and <code class="docutils literal notranslate"><span class="pre">.field.31</span></code>. As in the 1-dimensional case, all six of these fields are permuted by the symmetry operations acting on the object being projected, and to implement this equality all six of them compute to <code class="docutils literal notranslate"><span class="pre">.field.12</span></code> of a symmetrized input.</p>
<p>If any of the numbers goes above <code class="docutils literal notranslate"><span class="pre">9</span></code>, then the suffix can start instead with <code class="docutils literal notranslate"><span class="pre">..</span></code> and the numbers be separated by additional periods.  In other words, <code class="docutils literal notranslate"><span class="pre">.field.12</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">.field..1.2</span></code> but in the latter notation <code class="docutils literal notranslate"><span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">2</span></code> can also be multi-digit numbers.  Whereas, the twelfth field of a 12-dimensional version of a higher codatatype induced by a 1-dimensional field can be written <code class="docutils literal notranslate"><span class="pre">.field..12</span></code>.</p>
<p>When typechecking the type of a higher field in a <cite>codata</cite> definition, not only the argument variable but also all the <em>parameters in the context</em> are made higher-dimensional.  This is why we only defined <code class="docutils literal notranslate"><span class="pre">√ℕ</span></code> for a fixed constant type <code class="docutils literal notranslate"><span class="pre">ℕ</span></code>: if we tried to define it with a parameter we would have trouble:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def √ (A : Type) : Type ≔ codata [
| x .root.e : ?
]

 ￫ info[I0100]
 ￮ hole ?0 generated:

   A.0 : Type
   A.1 : Type
   A.2 : refl Type A.0 A.1
   x.0 : √ A.0
   x.1 : √ A.1
   x.2 : refl √ A.0 A.1 A.2 x.0 x.1
   ----------------------------------------------------------------------
   Type
</pre></div>
</div>
<p>So we can’t write <code class="docutils literal notranslate"><span class="pre">A</span></code> in this hole, since that would be interpreted as <code class="docutils literal notranslate"><span class="pre">A.2</span></code>, which is not a (0-dimensional) type until it is instantiated with elements of <code class="docutils literal notranslate"><span class="pre">A.0</span></code> and <code class="docutils literal notranslate"><span class="pre">A.1</span></code>.  Thus we see that <code class="docutils literal notranslate"><span class="pre">√</span></code> is not fully internalizable, as usual for an “amazing right adjoint”.</p>
<p>This degeneration of the context is essential, however, for arguably the most important example of a higher coinductive type, namely the definition of fibrancy in Higher Observational Type Theory as encoded in a substrate of internal binary parametricity.  This can be written in Narya as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def isFibrant (A : Type) : Type ≔ codata [
| x .trr.e : A.0 → A.1
| x .trl.e : A.1 → A.0
| x .liftr.e : (a₀ : A.0) → A.2 a₀ (x.2 .trr.1 a₀)
| x .liftl.e : (a₁ : A.1) → A.2 (x.2 .trl.1 a₁) a₁
| x .id.e : (a₀ : A.0) (a₁ : A.1) → isFibrant (A.2 a₀ a₁)
]
</pre></div>
</div>
<p>All five methods are 1-dimensional, so their types are defined in a higher-dimensional context consisting of</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>A.0 : Type
A.1 : Type
A.2 : Id Type A.0 A.1
x.0 : isFibrant A.0
x.1 : isFibrant A.1
x.2 : refl isFibrant A.0 A.1 A.2 x.0 x.1
</pre></div>
</div>
<p>In other words, the behavior of fibrancy only becomes visible once we have not just one fibrant type, but an equality between fibrant types (including their witnesses of fibrancy).  Given this, the fields <code class="docutils literal notranslate"><span class="pre">trr</span></code> and <code class="docutils literal notranslate"><span class="pre">trl</span></code> say that we can transport elements back and forth across such an equality, while the fields <code class="docutils literal notranslate"><span class="pre">liftr</span></code> and <code class="docutils literal notranslate"><span class="pre">liftl</span></code> give “path lifting” operations that “equate” each point to its transported version, heterogeneously along the family <code class="docutils literal notranslate"><span class="pre">A</span></code>.  Finally, the last field <code class="docutils literal notranslate"><span class="pre">id</span></code> says corecursively that the (heterogeneous) identity types of a fibrant type are again fibrant.  Taken together, this suffices to construct all the higher groupoid structure in homotopy type theory.  Some examples can be found in <code class="docutils literal notranslate"><span class="pre">test/black/hott.t</span></code>, including the proof that standard types inherit fibrancy, and that univalence holds.</p>
<p>When comatching against a higher coinductive type, the context is also degenerated when defining values for the higher fields.  For instance:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def t (x:A) : √ℕ ≔ [
| .root.e ↦ ?
]

 ￫ info[I0100]
 ￮ hole ?0 generated:

   x.0 : ℕ
   x.1 : ℕ
   x.2 : refl ℕ x.0 x.1
   ----------------------------------------------------------------------
   ℕ
</pre></div>
</div>
<p>If comatching against a higher-dimensional version of a higher coinductive type, you must give a clause for all instances of each field whose dimensions may be only <em>partially</em> specified.  For instance:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def f : Id √ℕ n₀ n₁ ≔ [
| .root.e ↦ ?
| .root.1 ↦ ?
]

  ￫ info[I3003]
  ￮ hole ?0:

   ----------------------------------------------------------------------
   refl ℕ (refl n₀ .root.1) (refl n₁ .root.1)

  ￫ info[I3003]
  ￮ hole ?1:

   ----------------------------------------------------------------------
    ℕ
</pre></div>
</div>
<p>In other words, <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">√ℕ</span> <span class="pre">n₀</span> <span class="pre">n₁</span></code> behaves like a higher coinductive type itself, which has one <em>ordinary</em> field <code class="docutils literal notranslate"><span class="pre">root.1</span></code> and one <em>higher</em> (1-dimensional) field <code class="docutils literal notranslate"><span class="pre">root.e</span></code>.  Similarly, instances of <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">(Id</span> <span class="pre">√ℕ)</span></code> are higher coinductive types with two ordinary fields <code class="docutils literal notranslate"><span class="pre">root.1</span></code> and <code class="docutils literal notranslate"><span class="pre">root.2</span></code> and one higher field <code class="docutils literal notranslate"><span class="pre">root.e</span></code>, and so on.</p>
</section>
</section>
<section id="parametrically-discrete-types">
<h2>Parametrically discrete types<a class="headerlink" href="#parametrically-discrete-types" title="Link to this heading"></a></h2>
<p>Discreteness is an experimental (and probably temporary) feature.  A (strictly parametrically) <em>discrete</em> type, in the sense meant here, is one whose higher-dimensional versions are all definitionally subsingletons.  That is, if <code class="docutils literal notranslate"><span class="pre">b1</span> <span class="pre">:</span> <span class="pre">A⁽ᵈ⁾</span> <span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b2</span> <span class="pre">:</span> <span class="pre">A⁽ᵈ⁾</span> <span class="pre">a</span></code>, then <code class="docutils literal notranslate"><span class="pre">b1</span></code> and <code class="docutils literal notranslate"><span class="pre">b2</span></code> are convertible (this is implemented as an η-rule).  Discreteness is currently restricted to arity 1 (including dTT), and can be enabled by the <code class="docutils literal notranslate"><span class="pre">-discreteness</span></code> flag (which is not included in <code class="docutils literal notranslate"><span class="pre">-dtt</span></code>).  When discreteness is enabled, a mutual family of datatypes will be marked as discrete if</p>
<ol class="arabic simple">
<li><p>All elements of the mutual family are datatypes; and</p></li>
<li><p>The types of all of their parameters, indices, and constructor arguments are either types belonging to the same family or previously defined discrete datatypes.</p></li>
</ol>
<p>Of the datatypes mentioned as examples above, the discrete ones are <code class="docutils literal notranslate"><span class="pre">ℕ</span></code>, <code class="docutils literal notranslate"><span class="pre">Bool</span></code>, and <code class="docutils literal notranslate"><span class="pre">⊥</span></code>.  Some other examples of discrete types are integers and binary trees:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def ℤ : Type ≔ data [
| zero.
| suc. (_:ℕ)
| negsuc. (_:ℕ)
]

def btree : Type ≔ data [
| leaf.
| node. (_:btree) (_:btree)
]
</pre></div>
</div>
<p>A family of datatypes indexed by discrete types can be discrete, such as inequality of natural numbers:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def ℕ.le : (k n : ℕ) → Type := data [
| zero. (n : ℕ) : ℕ.le zero. n
| suc. (k n : ℕ) (_ : ℕ.le k n) : ℕ.le (suc. k) (suc. n)
]
</pre></div>
</div>
<p>So can a mutual family of types:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def even : ℕ → Type ≔ data [
| zero. : even zero.
| suc. (n : ℕ) (_ : odd n) : even (suc. n)
]

and odd : ℕ → Type ≔ data [
| suc. (n : ℕ) (_ : even n) : odd (suc. n)
]
</pre></div>
</div>
<p>The higher-dimensional versions of a discrete datatype are also still themselves datatypes, so they have constructors and can be matched on.  In fact it should be possible to prove internally <em>without</em> <code class="docutils literal notranslate"><span class="pre">-discreteness</span></code> that these types are always propositionally contractible.  In particular, they are inhabited, so discreteness just adds some strictness, making them <em>definitionally</em> singletons.  For example, here is the proof that the displayed versions of <code class="docutils literal notranslate"><span class="pre">ℕ</span></code> are inhabited:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def ℕ.d (n : ℕ) : ℕ⁽ᵈ⁾ n ≔ match n [
| zero. ↦ zero.
| suc. n ↦ suc. (ℕ.d n)
]
</pre></div>
</div>
<p>Currently, the test for discreteness is performed immediately and only upon completion of the <code class="docutils literal notranslate"><span class="pre">def</span></code> command that defines a family of datatypes.  In particular, if the definition of a datatype contains a hole, it will not be considered discrete, even if the hole is later filled to make the definition one that would have been discrete if given from the get-go.  This could in theory be improved, but I am more likely to feel like putting effort into implementing the “correct” replacement for discrete types, namely modally-guarded parametricity such as full dTT.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="mutual-definitions.html" class="btn btn-neutral float-left" title="Mutual definitions" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="remarks.html" class="btn btn-neutral float-right" title="Remarks on implementation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Michael Shulman.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>