

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Names and notations &mdash; Narya 0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=2709fde1"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Imports and scoping" href="imports-and-scoping.html" />
    <link rel="prev" title="Built-in types" href="built-in-types.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Narya
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="top-level-interface.html">Top level interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="built-in-types.html">Built-in types</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Names and notations</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#mixfix-notations">Mixfix notations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#comments-and-strings">Comments and strings</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tokens">Tokens</a></li>
<li class="toctree-l2"><a class="reference internal" href="#identifiers">Identifiers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="imports-and-scoping.html">Imports and scoping</a></li>
<li class="toctree-l1"><a class="reference internal" href="typechecking.html">Typechecking details</a></li>
<li class="toctree-l1"><a class="reference internal" href="interactive.html">Interactive proof</a></li>
<li class="toctree-l1"><a class="reference internal" href="record-types.html">Record types and tuples</a></li>
<li class="toctree-l1"><a class="reference internal" href="data-types.html">Inductive datatypes and matching</a></li>
<li class="toctree-l1"><a class="reference internal" href="codata-types.html">Codatatypes and comatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="canonical-types.html">Canonical types defined by case trees</a></li>
<li class="toctree-l1"><a class="reference internal" href="mutual-definitions.html">Mutual definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="parametric-observational-type-theory.html">Parametric Observational Type Theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="remarks.html">Remarks on implementation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Narya</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Names and notations</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/names-and-notations.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="names-and-notations">
<h1>Names and notations<a class="headerlink" href="#names-and-notations" title="Link to this heading"></a></h1>
<section id="mixfix-notations">
<h2>Mixfix notations<a class="headerlink" href="#mixfix-notations" title="Link to this heading"></a></h2>
<p>The parser supports arbitrary mixfix operations with associativities and precedences, although we prefer to say “tightness” instead of “precedence”, to make it clear that higher numbers bind more tightly.  Tightnesses are <em>dyadic rational numbers</em> (i.e. having denominator a power of 2), written in decimal notation.  Tightnesses +ω and −ω also exist, but are reserved for internal use.  Some notations are built in, but the user can also declare new notations with the <code class="docutils literal notranslate"><span class="pre">notation</span></code> command mentioned above.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">PATTERN</span></code> of a notation is a list of interspersed distinct local variable names and double-quoted symbols, such as <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&quot;+&quot;</span> <span class="pre">y</span></code> for addition or <code class="docutils literal notranslate"><span class="pre">Γ</span> <span class="pre">&quot;⊢&quot;</span> <span class="pre">x</span> <span class="pre">&quot;⦂&quot;</span> <span class="pre">A</span></code> for a typing judgment.  Each quoted symbol must be exactly one token (see below); any two variables must be separated by a symbol (but two symbols can follow each other without a variable in between); and there must be at least one symbol.  If the pattern starts with a variable, it may be preceded by an ellipsis <code class="docutils literal notranslate"><span class="pre">…</span></code>, indicating that it is left-associative; and dually if it ends with a variable, it may be followed by an ellipsis, indicating that it is right-associative (but not both).</p>
<p>A notation which starts and ends with a variable is called “infix”; one that starts with a symbol and ends with a variable is called “prefix”; one that starts with a variable and ends with a symbol is called “postfix”; and one that starts and ends with a symbol is called “outfix”.  An outfix notation <em>may not</em> have a tightness (it always behaves as if it has tightness +ω).  All other notations must have a tightness, which is relevant only on the side(s) where they are “open” (both sides for an infix notation, the right for a prefix one, and the left for a postfix one).</p>
<p>As noted above, the meaning of a notation is defined by a <code class="docutils literal notranslate"><span class="pre">HEAD</span></code>, which is either a defined constant or a datatype constructor (see below), and <code class="docutils literal notranslate"><span class="pre">ARGUMENTS</span></code> that are a permutation of the pattern variables.  When the notation is encountered during parsing, it will be interpreted as a corresponding application of this head to the appropriate permutation of the terms appearing in the notation.  Conversely, this notation is also associated to the constant or constructor and will also be used for <em>printing</em> it in output.  A constant can be associated to only one notation for printing it; if additional notations are declared later, they will all remain usable for parsing, but only the most recently declared one will be used for printing.  A constructor can be associated to one printing notation for each number of arguments it could be applied to, since the same constructor name could be used at different datatypes with different numbers of arguments (see below).</p>
<p>We have already mentioned the right-associative function-type notation <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">→</span> <span class="pre">B</span></code>; this has tightness 0.  Function abstraction <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">↦</span> <span class="pre">M</span></code> is also right-associative, so you can write <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">↦</span> <span class="pre">y</span> <span class="pre">↦</span> <span class="pre">M</span></code> (which can also be abbreviated as <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">y</span> <span class="pre">↦</span> <span class="pre">M</span></code>), and has tightness −ω.  Application <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">N</span></code> is implemented specially since an ordinary notation cannot have two variables next to each other without a symbol in between, but it behaves as though it is left-associative with tightness +ω.  (In particular, a nonassociative prefix notation of tightness +ω, say <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>, will bind tighter than application, so that <code class="docutils literal notranslate"><span class="pre">&#64;</span> <span class="pre">f</span> <span class="pre">x</span></code> parses as <code class="docutils literal notranslate"><span class="pre">(&#64;</span> <span class="pre">f)</span> <span class="pre">x</span></code>.  However, there are no such notations yet.)</p>
<p>In addition, parentheses <code class="docutils literal notranslate"><span class="pre">(</span> <span class="pre">M</span> <span class="pre">)</span></code> are defined as an outfix notation, hence with effective tightness +ω.  This emphasizes that the “internal” locations of any notation (those with notation symbols on both sides) behave as if surrounded by parentheses; in particular, notations of any tightness, even −ω, can appear therein without further parenthesization.  Tightness and associativity only control what other notations can appear in the “external” locations that are delimited by a notation symbol on one side only.</p>
</section>
<section id="comments-and-strings">
<h2>Comments and strings<a class="headerlink" href="#comments-and-strings" title="Link to this heading"></a></h2>
<p>There are two kinds of comments.  A line comment starts with a backquote <code class="docutils literal notranslate"><span class="pre">`</span></code> and extends to the end of the line.  A block comment starts with <code class="docutils literal notranslate"><span class="pre">{`</span></code> and ends with <code class="docutils literal notranslate"><span class="pre">`}</span></code>.  Block comments can be nested and can contain line comments, but cannot start inside a line comment.</p>
<p>String literals are surrounded by double-quotes, as in <code class="docutils literal notranslate"><span class="pre">&quot;hello,</span> <span class="pre">world&quot;</span></code>.  At present the only use of string literals is in the <code class="docutils literal notranslate"><span class="pre">notation</span></code> command for defining user notations.</p>
</section>
<section id="tokens">
<h2>Tokens<a class="headerlink" href="#tokens" title="Link to this heading"></a></h2>
<p>A Narya source file is expected to be UTF-8 encoded and can contain arbitrary Unicode.  As usual, the code is first <em>lexed</em> by separating it into “tokens”, and then the sequence of tokens is <em>parsed</em> into an abstract syntax tree of notations.  Both identifiers (variable and constant names) and the symbols in a mixfix notation are tokens.  Whitespace (including comments) always creates a token boundary.  And since notation symbols can be made of the same characters that might be in an identifier, whitespace is sometimes necessary to separate identifiers from symbols.  For instance, if <code class="docutils literal notranslate"><span class="pre">⋆</span></code> is defined as a binary operator, we cannot write <code class="docutils literal notranslate"><span class="pre">x⋆y</span></code> (or even <code class="docutils literal notranslate"><span class="pre">1⋆1</span></code>) since that would be lexed as a single token.</p>
<p>However, in Narya there are the following exceptions to this, where whitespace is not needed to separate tokens:</p>
<ul>
<li><p>The characters <code class="docutils literal notranslate"><span class="pre">(</span> <span class="pre">)</span> <span class="pre">[</span> <span class="pre">]</span> <span class="pre">{</span> <span class="pre">}</span> <span class="pre">?</span> <span class="pre">→</span> <span class="pre">↦</span> <span class="pre">⤇</span> <span class="pre">≔</span> <span class="pre">⩴</span> <span class="pre">⩲</span> <span class="pre">…</span></code>, which either have built-in meaning or are reserved for future built-in meanings, are always treated as single tokens.  Thus, they do not need to be surrounded by whitespace.  This is the case for parentheses and braces in most languages, but in Narya you can also write, e.g., <code class="docutils literal notranslate"><span class="pre">A→B</span></code> without spaces.  The non-ASCII characters in this group all have ASCII-sequence substitutes that are completely interchangeable: <code class="docutils literal notranslate"><span class="pre">-&gt;</span> <span class="pre">|-&gt;</span> <span class="pre">|=&gt;</span> <span class="pre">:=</span> <span class="pre">::=</span> <span class="pre">+=</span> <span class="pre">...</span></code>.  Additional characters may be added to this list in the future.</p></li>
<li><p>A nonempty string consisting of the characters <code class="docutils literal notranslate"><span class="pre">~</span> <span class="pre">!</span> <span class="pre">&#64;</span> <span class="pre">#</span> <span class="pre">$</span> <span class="pre">%</span> <span class="pre">&amp;</span> <span class="pre">*</span> <span class="pre">/</span> <span class="pre">=</span> <span class="pre">+</span> <span class="pre">\</span> <span class="pre">|</span> <span class="pre">,</span> <span class="pre">&lt;</span> <span class="pre">&gt;</span> <span class="pre">:</span> <span class="pre">;</span> <span class="pre">-</span></code> is always treated as a single token, and does not need to be surrounded by whitespace.  Moreover, such tokens may only be notation symbols, not identifiers.  Note that this is most of the non-alphanumeric characters that appear on a standard US keyboard except for those that already have another meaning (parentheses, backquote, double quote, curly braces) or are allowed in identifiers (period, underscore, and single quote).  In particular:
- Ordinary algebraic operations like <code class="docutils literal notranslate"><span class="pre">+</span></code> and <code class="docutils literal notranslate"><span class="pre">*</span></code> can be defined so that <code class="docutils literal notranslate"><span class="pre">x+y</span></code> and <code class="docutils literal notranslate"><span class="pre">x*y</span></code> are valid.
- This includes the colon, so you can write <code class="docutils literal notranslate"><span class="pre">(x:A)</span> <span class="pre">→</span> <span class="pre">B</span></code>, and similarly for the comma <code class="docutils literal notranslate"><span class="pre">,</span></code> in a tuple and the bar <code class="docutils literal notranslate"><span class="pre">|</span></code> in a match or comatch (see below).  But the user can also use these characters in other operators.
- The ASCII substitutes for the single-token Unicode characters also fall into this category, so you can write for instance <code class="docutils literal notranslate"><span class="pre">A-&gt;B</span></code>.
- The ASCII hyphen <code class="docutils literal notranslate"><span class="pre">-</span></code> is in this category; in addition to its being part of <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">|-&gt;</span></code>, this allows a subtraction operator <code class="docutils literal notranslate"><span class="pre">x-y</span></code> to be written without spaces.  (Note, though, that the current parser does not permit a binary subtraction to coexist with a unary negation using the same character.)  Therefore, unlike in Agda, the hyphen is not allowed in identifiers.</p>
<p>This rule is intended to be a compromise, allowing the user to define plenty of infix operators that don’t require spacing but also arbitrary unicode operators, while keeping the lexer rules simple and unchanging as new operators are defined.  However, feedback is welcome!</p>
</li>
<li><p>A nonempty string such as <code class="docutils literal notranslate"><span class="pre">⁽¹ᵉ³⁾</span></code> consisting of Unicode superscript letter, digit, and hyphen characters, <code class="docutils literal notranslate"><span class="pre">ᵃᵇᶜᵈᵉᶠᵍʰⁱʲᵏˡᵐⁿᵒᵖʳˢᵗᵘᵛʷˣʸᶻ⁰¹²³⁴⁵⁶⁷⁸⁹⁻</span></code>, in between Unicode superscript parentheses, <code class="docutils literal notranslate"><span class="pre">⁽</span></code> and <code class="docutils literal notranslate"><span class="pre">⁾</span></code>, is treated as a single token and applied as a “superscript” operator to whatever immediately precedes it.  This is used for generic degeneracies (see below).  It binds more tightly than anything (tightness of “ω+1”), including function application, so that <code class="docutils literal notranslate"><span class="pre">f⁽ᵉ⁾</span> <span class="pre">x</span></code> means <code class="docutils literal notranslate"><span class="pre">(f⁽ᵉ⁾)</span> <span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x⁽ᵉ⁾</span></code> means <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">(x⁽ᵉ⁾)</span></code>.  In addition, a caret <code class="docutils literal notranslate"><span class="pre">^</span></code> followed by a nonempty string of the corresponding ASCII characters <code class="docutils literal notranslate"><span class="pre">abcdefghijklmnopqrstuvwxyz0123456789-</span></code> (no internal spaces!) in between ordinary parentheses <code class="docutils literal notranslate"><span class="pre">(</span></code> and <code class="docutils literal notranslate"><span class="pre">)</span></code> has exactly the same meaning with the same tightness: <code class="docutils literal notranslate"><span class="pre">f^(e)</span> <span class="pre">x</span></code> means the same as <code class="docutils literal notranslate"><span class="pre">f⁽ᵉ⁾</span> <span class="pre">x</span></code>.  (Unicode subscript characters are not treated specially; thus they may appear freely in identifiers or symbols, as may unicode superscripts not involving any parentheses.)</p></li>
</ul>
</section>
<section id="identifiers">
<h2>Identifiers<a class="headerlink" href="#identifiers" title="Link to this heading"></a></h2>
<p>Identifiers (variables and constant names) can be any string of non-whitespace characters, other than those mentioned above as special, that does not start or end with a period or an underscore, and is not a reserved word.  Currently the reserved words are</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>let rec in def and axiom echo notation import export solve show quit undo match return sig data codata
</pre></div>
</div>
<p>In particular, identifiers may start with a digit, or even consist entirely of digits (thereby shadowing a numeral notation, see below).  Internal periods in identifiers denote namespace qualifiers on constants; thus they cannot appear in local variable names.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="built-in-types.html" class="btn btn-neutral float-left" title="Built-in types" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="imports-and-scoping.html" class="btn btn-neutral float-right" title="Imports and scoping" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Michael Shulman.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>