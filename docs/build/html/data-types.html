

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Inductive datatypes and matching &mdash; Narya 0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=2709fde1"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Codatatypes and comatching" href="codata-types.html" />
    <link rel="prev" title="Record types and tuples" href="record-types.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Narya
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="top-level-interface.html">Top level interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="built-in-types.html">Built-in types</a></li>
<li class="toctree-l1"><a class="reference internal" href="names-and-notations.html">Names and notations</a></li>
<li class="toctree-l1"><a class="reference internal" href="imports-and-scoping.html">Imports and scoping</a></li>
<li class="toctree-l1"><a class="reference internal" href="typechecking.html">Typechecking details</a></li>
<li class="toctree-l1"><a class="reference internal" href="interactive.html">Interactive proof</a></li>
<li class="toctree-l1"><a class="reference internal" href="record-types.html">Record types and tuples</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Inductive datatypes and matching</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#defining-datatypes">Defining datatypes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#applying-constructors">Applying constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="#numeral-notations">Numeral notations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#matching">Matching</a></li>
<li class="toctree-l2"><a class="reference internal" href="#matching-and-case-trees">Matching and case trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="#recursion">Recursion</a></li>
<li class="toctree-l2"><a class="reference internal" href="#multiple-matches-and-deep-matches">Multiple matches and deep matches</a></li>
<li class="toctree-l2"><a class="reference internal" href="#empty-types-and-refutation-cases">Empty types and refutation cases</a></li>
<li class="toctree-l2"><a class="reference internal" href="#variable-matches">Variable matches</a></li>
<li class="toctree-l2"><a class="reference internal" href="#non-dependent-matches">Non-dependent matches</a></li>
<li class="toctree-l2"><a class="reference internal" href="#explicitly-dependent-matches">Explicitly dependent matches</a></li>
<li class="toctree-l2"><a class="reference internal" href="#matches-in-terms-and-case-trees">Matches in terms and case trees</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="codata-types.html">Codatatypes and comatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="canonical-types.html">Canonical types defined by case trees</a></li>
<li class="toctree-l1"><a class="reference internal" href="mutual-definitions.html">Mutual definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="parametric-observational-type-theory.html">Parametric Observational Type Theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="remarks.html">Remarks on implementation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Narya</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Inductive datatypes and matching</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/data-types.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="inductive-datatypes-and-matching">
<h1>Inductive datatypes and matching<a class="headerlink" href="#inductive-datatypes-and-matching" title="Link to this heading"></a></h1>
<section id="defining-datatypes">
<h2>Defining datatypes<a class="headerlink" href="#defining-datatypes" title="Link to this heading"></a></h2>
<p>An inductive datatype is defined by a number of <em>constructors</em>, each with a declared type that must be an iterated function-type whose eventual codomain is the datatype itself.  A constant of type <code class="docutils literal notranslate"><span class="pre">Type</span></code> can be defined to be a datatype in a <code class="docutils literal notranslate"><span class="pre">def</span></code> statement by using the keyword <code class="docutils literal notranslate"><span class="pre">data</span></code> and listing the constructors with their types in square brackets, separated by bars.  For instance, we can define the booleans:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def Bool : Type ≔ data [
| true. : Bool
| false. : Bool
]
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">|</span></code> before the first constructor is optional, and no spaces are required around the brackets and bar (unless, as usual, the bar is adjacent to a notation involving other special ASCII symbols).</p>
<p>Note that each constructor ends with a period.  This is intentionally dual to the fact that record fields (and codata methods, see below) <em>begin</em> with a period, and reminds us that constructors, like fields and records, are not namespaced but belong to a separate flat name domain.  (OCaml programmers should think of polymorphic variants, not regular variants, although there is no subtyping yet.)  The use of separate syntax distinguishing constructors from variables and functions is also familiar from functional programming, although the specific use of a dot suffix is unusual (capitalization is more common).</p>
<p>Also as with record types, this is not defining <code class="docutils literal notranslate"><span class="pre">Bool</span></code> to equal a pre-existing thing, but declaring it to be a new type that didn’t previously exist and doesn’t reduce to anything else.</p>
<p>Datatypes can have parameters:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def Sum (A B : Type) : Type ≔ data [
| inl. : A → Sum A B
| inr. : B → Sum A B
]
</pre></div>
</div>
<p>As with records, this is equivalent to</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def Sum : Type → Type → Type ≔ A B ↦ data [
| inl. : A → Sum A B
| inr. : B → Sum A B
]
</pre></div>
</div>
<p>When there are parameters, the output type must be the datatype applied to those same parameters.</p>
<p>The arguments of each constructor can also be written as parameters before its colon:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def Sum (A B : Type) : Type ≔ data [
| inl. (a : A) : Sum A B
| inr. (b : B) : Sum A B
]
</pre></div>
</div>
<p>When all the arguments (if any) are written this way, the output type can be omitted since we know what it must be (the datatype being defined):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def Sum (A B : Type) : Type ≔ data [
| inl. (a : A)
| inr. (b : B)
]
</pre></div>
</div>
<p>Of course, we can introduce a notation for this type after it is defined:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>notation 1 Sum : A &quot;⊔&quot; B ≔ Sum A B
</pre></div>
</div>
<p>But it is not currently possible to use a notation during the definition.</p>
<p>Datatypes can be recursive, meaning the inputs of a constructor can involve the datatype itself.  For instance, we have the natural numbers:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def ℕ : Type ≔ data [
| zero.
| suc. (_ : ℕ)
]
</pre></div>
</div>
<p>and the type of lists:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def List (A:Type) : Type ≔ data [
| nil.
| cons. (x : A) (xs: List A)
]
</pre></div>
</div>
<p>For consistency, such occurrences should be strictly positive, but this is not yet checked.  The parameters of a recursive datatype can be “non-uniform”, meaning that occurrences of the datatype in the inputs of a constructor (as opposed to the output) can be applied to different parameters.</p>
<p>A datatype can have zero constructors, yielding an empty type:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def ⊥ : Type ≔ data [ ]
</pre></div>
</div>
<p>Finally, a datatype can also have <em>indices</em>, which are arguments of its type that are not abstracted over (either as parameters, or with ↦ after the ≔) before issuing the <code class="docutils literal notranslate"><span class="pre">data</span></code> keyword.  In this case, all the constructors must include an explicit output type that specifies the values of the indices for that constructor (and also includes all the parameters explicitly, although these cannot differ between constructors).  For instance, we have vectors (length-indexed lists):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def Vec (A:Type) : ℕ → Type ≔ data [
| nil. : Vec A zero.
| cons. : (n:ℕ) → A → Vec A n → Vec A (suc. n)
]
</pre></div>
</div>
<p>As always for parameters of <code class="docutils literal notranslate"><span class="pre">def</span></code>, this is equivalent to</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def Vec : Type → ℕ → Type ≔ A ↦ data [
| nil. : Vec A zero.
| cons. : (n:ℕ) → A → Vec A n → Vec A (suc. n)
]
</pre></div>
</div>
<p>In particular, in the latter case <code class="docutils literal notranslate"><span class="pre">A</span></code> is still a parameter in the datatype sense, even though it does not appear to the left of the typing colon for <code class="docutils literal notranslate"><span class="pre">Vec</span></code>, because it is abstracted over before the <code class="docutils literal notranslate"><span class="pre">data</span></code> keyword.</p>
<p>The other classic example of a datatype with an index is the “Jdentity” type, in either Martin-Löf style:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def Jd (A:Type) : A → A → Type ≔ data [
| rfl. (a:A) : Jd A a a
]
</pre></div>
</div>
<p>or Paulin-Möhring style:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def Jd (A:Type) (a:A) : A → Type ≔ data [
| rfl. : Jd A a a
]
</pre></div>
</div>
</section>
<section id="applying-constructors">
<h2>Applying constructors<a class="headerlink" href="#applying-constructors" title="Link to this heading"></a></h2>
<p>A constructor, meaning an identifier ending with a period but containing no internal periods, can be applied to some number of arguments like a function, and then typechecked at a datatype that contains such a constructor.  For instance, <code class="docutils literal notranslate"><span class="pre">zero.</span></code> and <code class="docutils literal notranslate"><span class="pre">suc.</span> <span class="pre">zero.</span></code> and <code class="docutils literal notranslate"><span class="pre">suc.</span> <span class="pre">(suc.</span> <span class="pre">zero.)`</span></code> all typecheck at <code class="docutils literal notranslate"><span class="pre">ℕ</span></code>.</p>
<p>Constructors check rather than synthesizing.  As usual with checking terms, one constructor application can check at many different datatypes.  As a simple and common example, <code class="docutils literal notranslate"><span class="pre">nil.</span></code> typechecks at <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">A</span></code> for <em>any</em> type <code class="docutils literal notranslate"><span class="pre">A</span></code>.  This makes it clear that, unlike an ordinary function application, a constructor application cannot synthesize, as there is no way to guess from <code class="docutils literal notranslate"><span class="pre">nil.</span></code> what the type <code class="docutils literal notranslate"><span class="pre">A</span></code> should be.  Moreover, unlike in some other languages, the parameter <code class="docutils literal notranslate"><span class="pre">A</span></code> is not even an “implicit argument” of the constructor; the only way to make <code class="docutils literal notranslate"><span class="pre">nil.</span></code> synthesize is to ascribe it as <code class="docutils literal notranslate"><span class="pre">nil.</span> <span class="pre">:</span> <span class="pre">List</span> <span class="pre">A</span></code>.  Similarly, <code class="docutils literal notranslate"><span class="pre">inl.</span> <span class="pre">a</span></code> typechecks at <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">⊔</span> <span class="pre">B</span></code> for any type <code class="docutils literal notranslate"><span class="pre">B</span></code>.</p>
<p>Constructors must always be applied to all of their arguments.  For instance, one cannot write <code class="docutils literal notranslate"><span class="pre">cons.</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">List</span> <span class="pre">A</span> <span class="pre">→</span> <span class="pre">List</span> <span class="pre">A</span></code>.  You have to η-expand it: <code class="docutils literal notranslate"><span class="pre">(xs</span> <span class="pre">↦</span> <span class="pre">cons.</span> <span class="pre">x</span> <span class="pre">xs)</span> <span class="pre">:</span> <span class="pre">List</span> <span class="pre">A</span> <span class="pre">→</span> <span class="pre">List</span> <span class="pre">A</span></code>.  This might be improved in future.</p>
</section>
<section id="numeral-notations">
<h2>Numeral notations<a class="headerlink" href="#numeral-notations" title="Link to this heading"></a></h2>
<p>Natural number literals such as <code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">7</span></code>, and <code class="docutils literal notranslate"><span class="pre">23</span></code> are expanded at parse time into applications of the constructors <code class="docutils literal notranslate"><span class="pre">suc.</span></code> and <code class="docutils literal notranslate"><span class="pre">zero.</span></code>.  There is no built-in datatype with these constructors, but of course the user can define <code class="docutils literal notranslate"><span class="pre">ℕ</span></code> as above, in which case for instance <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">:</span> <span class="pre">ℕ</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">suc.</span> <span class="pre">(suc.</span> <span class="pre">(suc.</span> <span class="pre">zero.))</span></code>.  But numerals will also typecheck at any other datatype having constructors of the same name.</p>
</section>
<section id="matching">
<h2>Matching<a class="headerlink" href="#matching" title="Link to this heading"></a></h2>
<p>When a new constant is defined as a function with arguments that belong to datatypes, it can match on such an argument (called the <em>discriminee</em>).  For instance, the function that swaps the elements of a binary sum can be written as</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def Sum.swap (A B : Type) (x : A ⊔ B) : B ⊔ A ≔ match x [
| inl. a ↦ inr. a
| inr. b ↦ inl. b
]
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">|</span></code> before the first branch is optional.  Each branch is determined by one of the constructors of the datatype applied to distinct new “pattern variables” that are then bound in the body of that branch.  The body can then proceed to match again on these variables or on other variables.  For instance, we have associativity of sums:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def Sum.assoc (A B C : Type) (x : (A ⊔ B) ⊔ C) : A ⊔ (B ⊔ C) ≔ match x [
| inl. y ↦ match y [
  | inl. a ↦ inl. a
  | inr. b ↦ inr. (inl. b)
  ]
| inr. c ↦ inr. (inr. c)
]
</pre></div>
</div>
<p>By omitting the keyword <code class="docutils literal notranslate"><span class="pre">match</span></code> and the variable name, it is possible to abstract over a variable and simultaneously match against it (pattern-matching lambda abstraction).  Thus, <code class="docutils literal notranslate"><span class="pre">Sum.swap</span></code> can equivalently be defined as</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def Sum.swap (A B : Type) : A ⊔ B → B ⊔ A ≔ [
| inl. a ↦ inr. a
| inr. b ↦ inl. b
]
</pre></div>
</div>
<p>A match (of this simple sort) is a checking term.  It requires the term being matched against to synthesize, while the bodies of each branch are checking (we will discuss below how the type they are checked against is determined).</p>
</section>
<section id="matching-and-case-trees">
<h2>Matching and case trees<a class="headerlink" href="#matching-and-case-trees" title="Link to this heading"></a></h2>
<p>Matches are case tree nodes, which only reduce if the term being matched against is a constructor form so that one of the branches can be selected.  Thus, for instance, <code class="docutils literal notranslate"><span class="pre">Sum.swap</span> <span class="pre">x</span></code> does not reduce unless <code class="docutils literal notranslate"><span class="pre">x</span></code> is a constructor, and similarly for <code class="docutils literal notranslate"><span class="pre">Sum.assoc</span> <span class="pre">(inl.</span> <span class="pre">x)</span></code>.  This more or less aligns with the behavior of functions defined by pattern-matching in Agda, whereas Coq has to mimic it with <code class="docutils literal notranslate"><span class="pre">simpl</span> <span class="pre">nomatch</span></code> annotations.</p>
<p>However, unlike the other types and constructs we have discussed so far, matches and datatypes do not satisfy any kind of η-conversion.  Thus, two functions defined by matching are not equal to each other even if their definitions are identical.  For instance, if we define</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def neg1 : Bool → Bool ≔ [ true. ↦ false. | false. ↦ true. ]
def neg2 : Bool → Bool ≔ [ true. ↦ false. | false. ↦ true. ]
</pre></div>
</div>
<p>then <code class="docutils literal notranslate"><span class="pre">neg1</span></code> and <code class="docutils literal notranslate"><span class="pre">neg2</span></code> are not convertible.  By η-expansion, when trying to convert them we do automatically introduce a new variable <code class="docutils literal notranslate"><span class="pre">x</span></code> and try to compare <code class="docutils literal notranslate"><span class="pre">neg1</span> <span class="pre">x</span></code> with <code class="docutils literal notranslate"><span class="pre">neg2</span> <span class="pre">x</span></code>, but neither of these terms reduce since <code class="docutils literal notranslate"><span class="pre">x</span></code> is not a constructor.  In particular, datatypes do not satisfy any kind of η-conversion themselves.</p>
</section>
<section id="recursion">
<h2>Recursion<a class="headerlink" href="#recursion" title="Link to this heading"></a></h2>
<p>A function defined by matching can also be recursive, calling itself in each branch.  For instance, we have addition of natural numbers (in one of the possible ways):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def ℕ.plus (m n : ℕ) : ℕ ≔ match m [
| zero. ↦ n
| suc. m ↦ suc. (ℕ.plus m n)
]

notation 4 ℕ.plus : x &quot;+&quot; y ≔ ℕ.plus x y
</pre></div>
</div>
<p>To ensure termination and consistency, the recursive calls should be on structurally smaller arguments.  But currently there is no checking for this, so it is possible to write infinite loops.  In fact this is possible even without matching:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def oops : ⊥ ≔ oops
</pre></div>
</div>
<p>(In this connection, recall that <code class="docutils literal notranslate"><span class="pre">echo</span></code> fully normalizes its argument before printing it, so <code class="docutils literal notranslate"><span class="pre">echo</span> <span class="pre">oops</span></code> will loop forever.  By contrast, this does not usually happen with infinite loops guarded by a <code class="docutils literal notranslate"><span class="pre">match</span></code>, because matches are case tree nodes, so their branch bodies are not normalized unless their argument is a constructor that selects a particular branch.)</p>
<p>While there is no termination-checking there is coverage-checking.  Thus, all the constructors of a datatype must be present in the match.  So while you can write infinite loops, your programs shouldn’t get stuck.</p>
</section>
<section id="multiple-matches-and-deep-matches">
<h2>Multiple matches and deep matches<a class="headerlink" href="#multiple-matches-and-deep-matches" title="Link to this heading"></a></h2>
<p>It is possible to condense a sequence of nested matches into a single one.  For example, the above definition of <code class="docutils literal notranslate"><span class="pre">Sum.assoc</span></code> can be condensed into a single “deep match”:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def Sum.assoc (A B C : Type) (x : (A ⊔ B) ⊔ C) : A ⊔ (B ⊔ C) ≔ match x [
| inl. (inl. a) ↦ inl. a
| inl. (inr. b) ↦ inr. (inl. b)
| inr. c        ↦ inr. (inr. c)
]
</pre></div>
</div>
<p>Similarly, a naive definition of the Boolean conjunction would be:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def andb (x y : Bool) : Bool ≔ match x [
| true.  ↦ match y [
  | true.  ↦ true.
  | false. ↦ false.
  ]
| false. ↦ false.
]
</pre></div>
</div>
<p>but this can be condensed to a “multiple match”:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def andb (x y : Bool) : Bool ≔ match x, y [
| true.  , true.  ↦ true.
| true.  , false. ↦ false.
| false. , _      ↦ false.
]
</pre></div>
</div>
<p>Here the <code class="docutils literal notranslate"><span class="pre">_</span></code> indicates that that value can be anything.  It can also be replaced by a variable, which is then bound to the value being matched.</p>
<p>Multiple and deep matches can be combined.  In general, for a multiple match on a comma-separated list of a positive number of discriminees, the left-hand side of each branch must be a comma-separated list of the same number of <em>patterns</em>.  Each pattern is either a variable, an underscore, or a constructor applied to some number of other patterns.  Plain variable patterns are equivalent to let-bindings: <code class="docutils literal notranslate"><span class="pre">match</span> <span class="pre">x</span> <span class="pre">[</span> <span class="pre">y</span> <span class="pre">↦</span> <span class="pre">M</span> <span class="pre">]</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">y</span> <span class="pre">≔</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">M</span></code>.  Multiple and deep matches are (with one exception, discussed below) a <em>purely syntactic</em> abbreviation: the condensed forms are expanded automatically to the nested match forms before even being typechecked.</p>
<p>Multiple and deep patterns can also be used in pattern-matching abstractions.  In the case of a multiple match, the number of variables abstracted over is determined by the number of patterns in the branches.  Thus, for instance, <code class="docutils literal notranslate"><span class="pre">andb</span></code> can also be defined by:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def andb : Bool → Bool → Bool ≔ [
| true.  , true.  ↦ true.
| true.  , false. ↦ false.
| false. , _      ↦ false.
]
</pre></div>
</div>
<p>All the pattern variables of each branch must be distinct: they cannot shadow each other.  Allowing them to shadow each other would be a recipe for confusion, because replacing a match by its expanded version alters the order in which variables appear.  For instance, the nested match</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def prod&#39; (A B : Type) : Type ≔ data [ pair. (_:A) (_:B) ]

def proj31 (A B C : Type) (u : prod&#39; (prod&#39; A B) C) : A ≔ match u [
| pair. (pair. x y) z ↦ x
]
</pre></div>
</div>
<p>would expand to</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def proj31 (A B C : Type) (u : prod&#39; (prod&#39; A B) C) : A ≔ match u [
| pair. H z ↦ match H [
  | (pair. x y) ↦ x
  ]
]
</pre></div>
</div>
<p>in which <code class="docutils literal notranslate"><span class="pre">z</span></code> is bound first instead of last.  (The intermediate variable <code class="docutils literal notranslate"><span class="pre">H</span></code> is inserted automatically in the process of expansion, and you will see it in the contexts of holes.)</p>
<p>Matching always proceeds from left to right, so that the matches corresponding to the leftmost discriminee will be on the outside and those corresponding to the rightmost discriminee will be on the inside.  Of course, you can re-order the top-level discriminees as you wish when writing a match (an advantage over Agda’s pattern-matching).  However, if a constructor has multiple arguments which are then matched against deeply, these matches also proceed from left to right, and this cannot be changed within a single multi/deep match.  For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def andb2 (x : prod&#39; Bool Bool) : Bool ≔ match x [
| pair. true. true.   ↦ true.
| pair. true. false.  ↦ false.
| pair. false. true.  ↦ false.
| pair. false. false. ↦ false.
]
</pre></div>
</div>
<p>Here the first argument of <code class="docutils literal notranslate"><span class="pre">pair.</span></code> is matched before the second, producing the following expanded form:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def andb2 (x : prod&#39; Bool Bool) : Bool ≔ match x [
| pair. a b ↦ match a [
  | true. ↦ match b [
    | true. ↦ true.
    | false. ↦ false.
    ]
  | false. ↦ match b [
    | true. ↦ false.
    | false. ↦ false.
    ]
  ]
]
</pre></div>
</div>
<p>To match on the second argument first, you would have to use a nested match explicitly:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def andb2&#39; (x : prod&#39; Bool Bool) : Bool ≔ match x [
| pair. a b ↦ match b, a [
  | true.  , true.  ↦ true.
  | false. , true.  ↦ false.
  | true.  , false. ↦ false.
  | false. , false. ↦ false.
  ]
]
</pre></div>
</div>
<p>The patterns in a match are not allowed to overlap.  This is in contrast to Agda, which accepts the following definition</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>-- This is Agda, not Narya
max : Nat → Nat → Nat
max zero    n       = n
max m       zero    = m
max (suc m) (suc n) = suc (max m n)
</pre></div>
</div>
<p>The analogous Narya code</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>{` Not valid! `}
def max (x y : ℕ) : ℕ ≔ match x, y [
| zero. , n ↦ n
| m , zero. ↦ m
| suc. m, suc. n ↦ suc. (max m n)
]
</pre></div>
</div>
<p>produces an error message about overlapping cases.  You have to write instead</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def max (x y : ℕ) : ℕ ≔ match x, y [
| zero. , n ↦ n
| suc. m, zero. ↦ x
| suc. m, suc. n ↦ suc. (max m n)
]
</pre></div>
</div>
<p>so that it can be expanded to the nested match</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def max (x y : ℕ) : ℕ ≔ match x [
| zero. ↦ y
| suc. m ↦ match y [
  | zero. ↦ x
  | suc. n ↦ suc. (max m n)
  ]
]
</pre></div>
</div>
<p>In fact, this expansion is also what Agda does internally, even when presented with the first definition above (see the <a class="reference external" href="https://agda.readthedocs.io/en/v2.6.4.3-r1/language/function-definitions.html#case-trees">Agda manual</a>).  This means that in Agda, not all the clauses in such a definition may hold definitionally, e.g. <code class="docutils literal notranslate"><span class="pre">max</span> <span class="pre">m</span> <span class="pre">zero</span></code> is not convertible with <code class="docutils literal notranslate"><span class="pre">m</span></code> when <code class="docutils literal notranslate"><span class="pre">m</span></code> is a variable.  For this reason Agda has the <code class="docutils literal notranslate"><span class="pre">--exact-split</span></code> flag that prevents such clauses.  Narya <em>always</em> insists on “exact splits”, and this is unlikely to change: we regard it as a feature.</p>
</section>
<section id="empty-types-and-refutation-cases">
<h2>Empty types and refutation cases<a class="headerlink" href="#empty-types-and-refutation-cases" title="Link to this heading"></a></h2>
<p>As is well-known, it can be tricky to deal with empty types in multiple and deep matches.  A naive extension of the treatment of nonempty types can cause information to disappear, and while sometimes this information can be reconstructed, other times it must be indicated explicitly.  As a first example, consider the following function defined by nested matches:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def foldinl (x : (A ⊔ A) ⊔ ⊥ ) : A ≔ match x [
| inl. u ↦ match u [
  | inl. a ↦ a
  | inr. a ↦ a
  ]
| inr. v ↦ match v [ ]
]
</pre></div>
</div>
<p>If we rewrite this as a deep match, each branch of the outer match should be replaced by one branch for <em>each branch</em> of the corresponding inner match; but since the inner match on <code class="docutils literal notranslate"><span class="pre">v</span></code> has <em>zero</em> branches, this causes the outer branch with pattern <code class="docutils literal notranslate"><span class="pre">inr.</span> <span class="pre">v</span></code> to disappear completely:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def foldinl (x : (A ⊔ A) ⊔ ⊥ ) : A ≔ match x [
| inl. (inl. a) ↦ a
| inl. (inr. a) ↦ a
]
</pre></div>
</div>
<p>In this example, this is not a problem, because Narya (like other proof assistants) can recognize from the type of <code class="docutils literal notranslate"><span class="pre">x</span></code> <em>and the fact that there is at least one ``inl`` branch</em> that there should also be an <code class="docutils literal notranslate"><span class="pre">inr</span></code> branch — and once there is an <code class="docutils literal notranslate"><span class="pre">inr</span></code> branch, it is straightforward to notice that the argument of <code class="docutils literal notranslate"><span class="pre">inr</span></code> is empty and thus can be matched against without needing any further branches.</p>
<p>This also works for multiple matches:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def P : A ⊔ B → Type ≔ [ inl. _ ↦ ⊤ | inr. _ ↦ ⊥ ]

def foo (u : A ⊔ B) (v : P u) : A ≔ match u, v [
| inl. a, _ ↦ a
]
</pre></div>
</div>
<p>Again the presence of an <code class="docutils literal notranslate"><span class="pre">inl</span></code> branch clues Narya in that there should also be an <code class="docutils literal notranslate"><span class="pre">inr</span></code> branch, and then it can notice that in this branch the type of <code class="docutils literal notranslate"><span class="pre">v</span></code> becomes empty.  The order of variables doesn’t matter either:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def foo&#39; (u : A ⊔ B) (v : P u) : A ≔ match v, u [
| _, inl. a ↦ a
]
</pre></div>
</div>
<p>In general, when cases for one or more constructors are obviously missing from a match, Narya will inspect all the pattern variables and discriminees that would be available in that branch, and if it finds one whose type is empty, it inserts a match against that term.  Here by “empty” we mean that it was literally declared as a datatype with no constructors: there is no unification like in Agda to rule out impossible indices (although see the remarks about canonical types defined by case trees, below).  This is the exception mentioned above in which the expansion of multiple and deep matches requires some typechecking information: namely, whether the type of some variable is an empty datatype.</p>
<p>As a particular case, if any of the discriminees belong directly to an empty datatype, then all the branches can be omitted.  Similarly, an empty pattern-matching lambda abstraction <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">]</span></code> can be a multivariable function, although in this case there are no branches to indicate the number of arguments; instead Narya inspects the possibly-iterated function type it is being checked at, looking through the domains one at a time until it finds an empty one.  Thus the following are both valid:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def bar (x : Bool) (y : ⊥) : ⊥ ≔ match x, y [ ]

def bar&#39; : Bool → ⊥ → ⊥ ≔ [ ]
</pre></div>
</div>
<p>However, Narya will not perform <em>additional</em> matches in order to expose an inhabitant of an empty datatype (this is probably an undecidable problem in general).  For example, consider the following nested match:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def abort2 (u : ⊥ ⊔ ⊥) : A ≔ match u [
| inl. e ↦ match e [ ]
| inr. e ↦ match e [ ]
]
</pre></div>
</div>
<p>Rewriting this naïvely as as nested match would produce one with <em>zero</em> branches, but trying to write such a match directly fails:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def abort2 (u : ⊥ ⊔ ⊥) : A ≔ match u [ ]

  ￫ error[E1300]
  1 | def abort2 (u : ⊥ ⊔ ⊥) : A ≔ match u [ ]
   ^ missing match clause for constructor inl
</pre></div>
</div>
<p>This is because in the absence of either an <code class="docutils literal notranslate"><span class="pre">inl</span></code> or an <code class="docutils literal notranslate"><span class="pre">inr</span></code> branch, and because the type of <code class="docutils literal notranslate"><span class="pre">u</span></code> is not syntactically empty (semantically it is empty, but it is not declared as a datatype with zero constructors), Narya can’t guess that <code class="docutils literal notranslate"><span class="pre">u</span></code> has to be matched against in order to expose variables of type ⊥.</p>
<p>One solution to this, of course, is to write the nested match.  In fact, only one of its branches is needed, as then the other can be inferred:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def abort2 (u : ⊥ ⊔ ⊥) : A ≔ match u [
| inl. e ↦ match e [ ]
]
</pre></div>
</div>
<p>Another solution is to use a <em>refutation case</em>: if the body of a branch is a single dot <code class="docutils literal notranslate"><span class="pre">.</span></code> then Narya will search all of its pattern variables for one belonging to an empty type:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def abort2 (u : ⊥ ⊔ ⊥) : A ≔ match u [
| inl. _ ↦ .
| inr. _ ↦ .
]
</pre></div>
</div>
<p>And, again, only one branch is necessary:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def abort2 (u : ⊥ ⊔ ⊥) : A ≔ match u [
| inl. _ ↦ .
]
</pre></div>
</div>
</section>
<section id="variable-matches">
<h2>Variable matches<a class="headerlink" href="#variable-matches" title="Link to this heading"></a></h2>
<p>There are several variations of matching based on how type information flows and is refined.  Probably the most important kind of matching is when the discriminee is a free variable that belongs to a datatype instance whose indices are distinct free variables not occurring in any of the parameters, and the match is in a checking context.  In this case, the output type <em>and</em> the types of all other variables in the context are <em>refined</em> while checking each branch of the match, by substituting the corresponding constructor applied to its pattern variables, and its corresponding indices, for these free variables.  This is similar to the behavior of Agda when splitting a definition on a variable.</p>
<p>For example, we can prove that natural number addition is associative:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def ℕ.plus.assoc (m n p : ℕ) : Id ℕ ((m+n)+p) (m+(n+p)) ≔ match m [
| zero. ↦ refl (n+p)
| suc. m&#39; ↦ suc. (ℕ.plus.assoc m&#39; n p)
]
</pre></div>
</div>
<p>This proof uses observational identity types, which are introduced below.  But the point here is that in the <code class="docutils literal notranslate"><span class="pre">suc.</span></code> branch, the variable <code class="docutils literal notranslate"><span class="pre">m</span></code> is defined to equal <code class="docutils literal notranslate"><span class="pre">suc.</span> <span class="pre">m'</span></code>, and this definition is substituted into the goal type <code class="docutils literal notranslate"><span class="pre">Id</span> <span class="pre">ℕ</span> <span class="pre">((m+n)+p)</span> <span class="pre">(m+(n+p))</span></code>, causing both additions to reduce one step.  You can see this by inserting a hole in this clause:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def ℕ.plus.assoc (m n p : ℕ) : Id ℕ ((m+n)+p) (m+(n+p)) ≔ match m [
| zero. ↦ refl (n+p)
| suc. m&#39; ↦ ?
]

     hole ?0 generated:

     n : ℕ
     p : ℕ
     m&#39; : ℕ
     m ≔ suc. m&#39; : ℕ
     ----------------------------------------------------------------------
     refl ℕ (suc. ((m&#39; + n) + p)) (suc. (m&#39; + (n + p)))
</pre></div>
</div>
<p>As an example with indices, we can define appending of vectors:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def Vec.append (A : Type) (m n : ℕ) (v : Vec A m) (w : Vec A n) : Vec A (ℕ.plus m n) ≔ match v [
| nil. ↦ w
| cons. k a u ↦ cons. (ℕ.plus k n) a (Vec.append A k n u w)
]
</pre></div>
</div>
<p>Here the match against <code class="docutils literal notranslate"><span class="pre">v</span></code> falls into this case of matching because <code class="docutils literal notranslate"><span class="pre">v</span></code> and the index <code class="docutils literal notranslate"><span class="pre">m</span></code> of its type <code class="docutils literal notranslate"><span class="pre">Vec</span> <span class="pre">A</span> <span class="pre">m</span></code> are both free variables.  Then in the two branches, not only is <code class="docutils literal notranslate"><span class="pre">v</span></code> specialized to the constructor, the variable <code class="docutils literal notranslate"><span class="pre">m</span></code> is also specialized to the index value associated to that constructor, namely <code class="docutils literal notranslate"><span class="pre">zero.</span></code> in the first branch and <code class="docutils literal notranslate"><span class="pre">suc.</span> <span class="pre">k</span></code> in the second.  Again, you can see this with a hole:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def Vec.append (A : Type) (m n : ℕ) (v : Vec A m) (w : Vec A n) : Vec A (ℕ.plus m n) ≔ match v [
| nil. ↦ w
| cons. k a u ↦ ?
]

     hole ?1 generated:

     A : Type
     n : ℕ
     w : Vec A n
     k : ℕ
     m ≔ suc. k : ℕ
     a : A
     u : Vec A k
     v ≔ cons. k a u : Vec A (suc. k)
     ----------------------------------------------------------------------
     Vec A (suc. (k + n))
</pre></div>
</div>
<p>(Note that the body of the second branch typechecks because <code class="docutils literal notranslate"><span class="pre">ℕ.plus</span> <span class="pre">(suc.</span> <span class="pre">k)</span> <span class="pre">n</span></code> reduces to <code class="docutils literal notranslate"><span class="pre">suc.</span> <span class="pre">(ℕ.plus</span> <span class="pre">k</span> <span class="pre">n)</span></code>, which is why we defined addition of natural numbers as we did.  The other addition of natural numbers, by recursion on the second argument, instead aligns with appending of <em>backwards</em> vectors.)</p>
<p>The fact that the indices cannot occur in the parameters prevents us, for instance, from proving Axiom K.  Thus it is even less general than Agda’s <code class="docutils literal notranslate"><span class="pre">--without-K</span></code> matching, and hence also ensures consistency with univalence.  In the future we may implement a more general unification-based condition like Agda’s.</p>
</section>
<section id="non-dependent-matches">
<h2>Non-dependent matches<a class="headerlink" href="#non-dependent-matches" title="Link to this heading"></a></h2>
<p>It is also possible to match against a term that is not a free variable, or whose indices are not distinct free variables or occur in the parameters.  In this case Narya cannot guess how to refine the output type or other variables in the context, so it doesn’t.  The term being matched against is not defined to equal anything (that doesn’t even make sense); instead the pattern variables in each branch are simply introduced as new free variables unrelated to any previous ones, and the output type remains the same in each branch.  As a simple example, we can prove <em>ex falso quodlibet</em> without a helper function:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def ⊥ : Type ≔ data [ ]

def efq (A C : Type) (a : A) (na : A → ⊥) : C ≔ match na a [ ]
</pre></div>
</div>
<p>Note that matching against a let-bound variable is equivalent to matching against its value, so it falls under this category.</p>
<p>The fact that this kind of match uses the same syntax as the previous one means that if you intend to do a variable match, as above, but the conditions on the match variable and its indices are not satisfied, then Narya will fall back to trying this kind of match.  You will then probably get an error message due to the fact that the goal type didn’t get refined in the branches the way you were expecting it to.  Narya tries to help you find bugs of this sort by emitting a hint when that sort of fallback happens.  If you really did mean to write a non-dependent match, you can silence the hint by writing <code class="docutils literal notranslate"><span class="pre">match</span> <span class="pre">M</span> <span class="pre">return</span> <span class="pre">_</span> <span class="pre">↦</span> <span class="pre">_</span></code> (see the next sort of match, below).</p>
<p>A variable match can only check, but a non-dependent match can also synthesize.  This requires at least one of the branch bodies to synthesize a type that does not depend on any of its pattern variables; then the other branches are checked against that same type, and it is the type synthesized by the whole match statement.  Writing a match that could have been a variable match but in a synthesizing context will also cause an automatic fallback to non-dependent matching, with a hint emitted.</p>
<p>Like the ordinary <code class="docutils literal notranslate"><span class="pre">match</span></code> command, a pattern-matching abstraction like <code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">pred</span> <span class="pre">:</span> <span class="pre">ℕ</span> <span class="pre">→</span> <span class="pre">ℕ</span> <span class="pre">≔</span> <span class="pre">[</span> <span class="pre">zero.</span> <span class="pre">↦</span> <span class="pre">zero.</span> <span class="pre">|</span> <span class="pre">suc.</span> <span class="pre">n</span> <span class="pre">↦</span> <span class="pre">n</span> <span class="pre">]</span></code> always attempts to generate a match against a variable, and falls back to a non-dependent match if this fails (e.g. if the domain does not have fully general indices).</p>
</section>
<section id="explicitly-dependent-matches">
<h2>Explicitly dependent matches<a class="headerlink" href="#explicitly-dependent-matches" title="Link to this heading"></a></h2>
<p>Although Narya can’t guess how to refine the output type when matching against a general term, you can tell it how to do so by writing <code class="docutils literal notranslate"><span class="pre">match</span> <span class="pre">M</span> <span class="pre">return</span> <span class="pre">x</span> <span class="pre">↦</span> <span class="pre">P</span></code>.  Here <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">↦</span> <span class="pre">P</span></code> (where <code class="docutils literal notranslate"><span class="pre">P</span></code> can involve <code class="docutils literal notranslate"><span class="pre">x</span></code>) is a type family (called the <em>motive</em>) depending on a variable <code class="docutils literal notranslate"><span class="pre">x</span></code> belonging to the datatype (the type of <code class="docutils literal notranslate"><span class="pre">M</span></code>).  If this datatype has indices, then variables to be bound to the indices must be included in the abstraction as well, e.g. <code class="docutils literal notranslate"><span class="pre">match</span> <span class="pre">V</span> <span class="pre">return</span> <span class="pre">i</span> <span class="pre">v</span> <span class="pre">↦</span> <span class="pre">P</span></code> for matching against a vector; this ensures that the motive of the elimination is fully general over the indexed datatype family.  Thus, this kind of match has roughly the same functionality as Coq’s <code class="docutils literal notranslate"><span class="pre">match</span> <span class="pre">M</span> <span class="pre">in</span> <span class="pre">T</span> <span class="pre">i</span> <span class="pre">as</span> <span class="pre">x</span> <span class="pre">return</span> <span class="pre">P</span></code>.</p>
<p>Each branch of such a match is checked at the type obtained by substituting the corresponding constructor for <code class="docutils literal notranslate"><span class="pre">x</span></code> in the motive <code class="docutils literal notranslate"><span class="pre">P</span></code>.  The entire match synthesizes the result of substituting the discriminee <code class="docutils literal notranslate"><span class="pre">M</span></code> for <code class="docutils literal notranslate"><span class="pre">x</span></code> in the motive <code class="docutils literal notranslate"><span class="pre">P</span></code>.  For example, we could prove associativity of addition more verbosely as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def ℕ.plus.assoc (m n p : ℕ) : Id ℕ ((m+n)+p) (m+(n+p))
  ≔ match m return x ↦ Id ℕ ((x+n)+p) (x+(n+p)) [
  | zero. ↦ refl (n+p)
  | suc. m&#39; ↦ suc. (ℕ.plus.assoc m&#39; n p)
  ]
</pre></div>
</div>
<p>As usual, the variables bound in the motive can be written as underscores if they are not used; thus with <code class="docutils literal notranslate"><span class="pre">match</span> <span class="pre">M</span> <span class="pre">return</span> <span class="pre">_</span> <span class="pre">↦</span> <span class="pre">P</span></code> you can specify a constant motive explicitly.  This is equivalent to ascribing the entire match to type <code class="docutils literal notranslate"><span class="pre">P</span></code>, but it forces the match to be a non-dependent one.  You can also write <code class="docutils literal notranslate"><span class="pre">match</span> <span class="pre">M</span> <span class="pre">return</span> <span class="pre">_</span> <span class="pre">↦</span> <span class="pre">_</span></code> in a checking context (with the correct number of variables for the indices, if any) to indicate that the output type is intentionally constant, silencing any hints about fallback, without having to specify that output type explicitly.</p>
<p>A match with an explicit motive cannot have more than one discriminee.  It would be rather complicated to work out, and indicate syntactically, the dependence of such a motive on all the discriminees.  Of course, you can write your own nested sequence of matches.  However, deep matching on one discriminee is still available with an explicit motive.  Upon expansion, only the outermost match will retain the explicit motive, the inner matches becoming implicit.</p>
<p>Note that while this kind of match provides a way to explicitly refine the <em>output</em> type when matching against a non-variable term, unlike a variable match, it does not do anything to the types of other variables in the context.  If you want their types to also be refined in the branches when doing an explicitly dependent match, you have to use the <a class="reference external" href="http://adam.chlipala.net/cpdt/html/MoreDep.html">convoy pattern</a> as in Coq.</p>
</section>
<section id="matches-in-terms-and-case-trees">
<h2>Matches in terms and case trees<a class="headerlink" href="#matches-in-terms-and-case-trees" title="Link to this heading"></a></h2>
<p>The other case tree constructs we have discussed, such as abstraction and tuples, can also occur in arbitrary locations in a term.  The same is true for matches, but the behavior of such matches is somewhat subtle.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">match</span></code> were an ordinary kind of term syntax, Narya would have to be able to check whether two <code class="docutils literal notranslate"><span class="pre">match</span></code> expressions are equal.  Matches don’t satisfy η-conversion, so such an equality-check would have to descend into the branch bodies, and this would require <em>normalizing</em> those bodies.  Now suppose a function were defined recursively using a match outside its case tree; then it would evaluate to a match expression even if its argument is not a constructor, and it would appear itself in one of the branches of that match expression; thus, this would lead to an infinite regress of normalization.  This is probably not an impossible problem to solve (e.g. Coq has fixpoint terms and match terms and manages to check equality), but it would be complicated and does not seem worth the trouble.</p>
<p>Narya’s solution is similar to that of Agda: matches outside case trees are <em>generative</em>.  (Note that matches inside case trees are also generative in the sense that all constants defined by case trees are generative.)  Each textual occurrence of a match is, in effect, lifted to a top-level definition (actually, a metavariable) which contains the match <em>inside</em> its case tree, and therefore doesn’t reduce to anything unless the discriminee is a constructor.  In particular, therefore, two such matches, even if they look identical, generate distinct lifted top-level definitions and thus are not definitionally equal (until their discriminees become constructors and they reduce to corresponding branches).  This sort of lifting allows us to say that, technically, <code class="docutils literal notranslate"><span class="pre">match</span></code> is <em>only</em> allowed in case trees, and any occurrences outside of case trees are silently elaborated into case trees.</p>
<p>Narya attempts to be “smart” about such lifting in a couple of ways.  Firstly (and perhaps obviously), once a <code class="docutils literal notranslate"><span class="pre">match</span></code> is encountered in a term and lifted to the case tree of a top-level definition, that case tree continues as usual into the branches of the match, including all operations that are valid in case trees such as abstractions, tuples, and other matches, until it reaches a leaf that can’t be a case tree node.  Thus, reduction of such a match is blocked not only on its own discriminee, but on those of all directly subsequent matches appearing in its branches.</p>
<p>Secondly, if a <code class="docutils literal notranslate"><span class="pre">match</span></code> appears directly as the value of a <code class="docutils literal notranslate"><span class="pre">let</span></code> binding (or nested only inside other case tree constructs), then the <em>entire</em> value of the let-binding is lifted to top-level as a case tree definition, and then bound locally to the <code class="docutils literal notranslate"><span class="pre">let</span></code> variable.  Thus, <code class="docutils literal notranslate"><span class="pre">let</span></code> can be treated like a local version of <code class="docutils literal notranslate"><span class="pre">def</span></code>, defining a function locally by a case tree that doesn’t reduce until applied to enough arguments, field projections, and constructors.  Unlike a <code class="docutils literal notranslate"><span class="pre">def</span></code>, however, the <em>default</em> behavior of <code class="docutils literal notranslate"><span class="pre">let</span></code> is to interpret its argument as a term rather than a case tree: it only interprets its argument as a case tree if there are case-tree-only constructs like <code class="docutils literal notranslate"><span class="pre">match</span></code> that <em>would</em> be included in it under such an interpretation.  Thus, for instance,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def point : ℕ × ℕ
  ≔ let p : ℕ × ℕ ≔ (1,2) in
    p

echo point
</pre></div>
</div>
<p>will print <code class="docutils literal notranslate"><span class="pre">(1,2)</span></code>, in contrast to how <code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">point</span> <span class="pre">:</span> <span class="pre">ℕ</span> <span class="pre">×</span> <span class="pre">ℕ</span> <span class="pre">≔</span> <span class="pre">(1,2)</span></code> would be printed simply as <cite>point</cite> since the tuple would be part of the case tree (unless the product type <code class="docutils literal notranslate"><span class="pre">×</span></code> is transparent or translucent).  But, for instance, if we define a function locally to pass to some other functional, that local function can be defined by matching:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def sq (f : ℕ → ℕ) : ℕ → ℕ ≔ x ↦ f (f x)

def sqdec1 (x : ℕ) : ℕ ≔
  let dec : ℕ → ℕ ≔ y ↦ match y [ zero. ↦ zero. | suc. n ↦ n ] in
  sq dec x
</pre></div>
</div>
<p>Such local functions are very like Agda’s <code class="docutils literal notranslate"><span class="pre">where</span></code> clauses.  They cannot yet be defined with parameter syntax (e.g. “<code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">dec</span> <span class="pre">(y:ℕ)</span> <span class="pre">:</span> <span class="pre">ℕ</span> <span class="pre">≔</span></code>”), but we can use a pattern-matching lambda for a one-variable function:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def sqdec2 (x : ℕ) : ℕ ≔
  let dec : ℕ → ℕ ≔ [ zero. ↦ zero. | suc. n ↦ n ] in
  sq dec x
</pre></div>
</div>
<p>Of course, we can also just pass the pattern-matching lambda directly as a term on its own:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def sqdec3 ≔ sq [ zero. ↦ zero. | suc. n ↦ n ]
</pre></div>
</div>
<p>However, a let-bound local function can use a <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">rec</span></code> instead to define a local recursive function, which is not possible with a pattern-matching lambda:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def sqdbl (x : ℕ) : ℕ ≔
  let rec dbl : ℕ → ℕ ≔ y ↦ match y [ zero. ↦ zero. | suc. n ↦ suc. (suc. (dbl n)) ] in
  sq dbl x
</pre></div>
</div>
<p>In fact, <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">rec</span></code> is <em>always</em> treated generatively and lifted to top-level like an ordinary <code class="docutils literal notranslate"><span class="pre">let</span></code> that contains a <code class="docutils literal notranslate"><span class="pre">match</span></code>.  Indeed, in the absence of something like a “fixpoint” operator there is no other possibility, as there is no term syntax for it to evaluate to.</p>
<p>Currently, such local case trees are not printed very comprehensibly if they “escape” from their site of definition.  For instance:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>axiom z : ℕ

echo sqdec2 z
</pre></div>
</div>
<p>prints something like <code class="docutils literal notranslate"><span class="pre">_let.0.dec{…}</span> <span class="pre">(_let.0.dec{…}</span> <span class="pre">z)</span></code>, where the number is a metavariable counter.  The name <code class="docutils literal notranslate"><span class="pre">_let.0.dec</span></code> is not a valid user-defined identifier since it begins with an underscore, and so this notation is not re-parseable; but it indicates that there is some locally defined function, which was called <code class="docutils literal notranslate"><span class="pre">dec</span></code> where it was defined but is not in scope any more, and is being applied twice to the argument <code class="docutils literal notranslate"><span class="pre">z</span></code>.  The notation <code class="docutils literal notranslate"><span class="pre">{…}</span></code> is like that used for a hole, indicating that this local function might also have an un-notated substitution applied to the context in which it was defined.  As noted above, like any other global constant defined by a case tree, <code class="docutils literal notranslate"><span class="pre">_let.0.dec</span></code> does not evaluate at all unless it reaches a leaf of its case tree; thus <code class="docutils literal notranslate"><span class="pre">_let.0.dec{…}</span> <span class="pre">(_let.0.dec{…}</span> <span class="pre">z)</span></code> does not reduce further since <code class="docutils literal notranslate"><span class="pre">z</span></code> is not a constructor.  (But <code class="docutils literal notranslate"><span class="pre">sqdec</span> <span class="pre">(suc.</span> <span class="pre">z)</span></code> will, of course, reduce once to <code class="docutils literal notranslate"><span class="pre">_let.0.dec{…}</span> <span class="pre">z</span></code>.)</p>
<p>As noted above, such local case trees are generative: textually identical definitions given in two different places will produce unequal values.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def dec1_is_dec2 ≔
  let dec : ℕ → ℕ ≔ [ zero. ↦ zero. | suc. n ↦ n ] in
  let dec1 ≔ dec in
  let dec : ℕ → ℕ ≔ [ zero. ↦ zero. | suc. n ↦ n ] in
  let dec2 ≔ dec in
  Jd (ℕ → ℕ) dec1 dec2

def fails : dec1_is_dec2 ≔ rfl.

   ￫ error[E1003]
 1 | def fails : dec1_is_dec2 ≔ rfl.
   ^ index
       _let.1.dec{…}
     of constructor application doesn&#39;t match the corresponding index
       _let.2.dec{…}
     of datatype instance
</pre></div>
</div>
<p>Note that both local functions are called <code class="docutils literal notranslate"><span class="pre">_let.N.dec</span></code> based on their name when defined, but their metavariable counters are different, and they are unequal.</p>
<p>A match not occuring inside any <code class="docutils literal notranslate"><span class="pre">let</span></code> value doesn’t even have a user-assigned name like <code class="docutils literal notranslate"><span class="pre">dec</span></code>, so it is printed only with a number.  For instance, <code class="docutils literal notranslate"><span class="pre">echo</span> <span class="pre">sqdec3</span></code> from above will print something like <code class="docutils literal notranslate"><span class="pre">sq</span> <span class="pre">(H</span> <span class="pre">↦</span> <span class="pre">_match.3{…})</span></code>.  Note that the dependence of the match on the variable (which Narya named <code class="docutils literal notranslate"><span class="pre">H</span></code>) is not even indicated (it is hidden in the context substitution <code class="docutils literal notranslate"><span class="pre">{…}</span></code>).  However, the advantage of matches of this sort is that, unlike the value of a let-bound variable, they can check rather than synthesize.</p>
<p>The printing of local case trees will hopefully be improved somewhat in future, but there is a limit to how much improvement is possible.  Moreover, overuse of local case trees can make it difficult to prove theorems about a function: facts one may need about its components cannot easily be separated out into lemmas since the pieces cannot easily be referred to.  Thus, while this sort of code can be convenient for programming, and in simple cases (such as <code class="docutils literal notranslate"><span class="pre">match</span> <span class="pre">e</span> <span class="pre">[</span> <span class="pre">]</span></code> to fill any checking context, given any <code class="docutils literal notranslate"><span class="pre">e:⊥</span></code>), it is often better eschewed in favor of additional explicit global helper functions.  For this reason, Narya currently emits a hint whenever it detects a “bare” case-tree-only construct and interprets it in this way.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="record-types.html" class="btn btn-neutral float-left" title="Record types and tuples" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="codata-types.html" class="btn btn-neutral float-right" title="Codatatypes and comatching" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Michael Shulman.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>